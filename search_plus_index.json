{"./":{"url":"./","title":"简介","keywords":"","body":"我的电子书 [!TIP] 这是我的第一个电子书 从 vuepress 到 vitepress ， 再到现在的 gitbook ， 它们无疑都是很好的文档管理工具 现在使用其书写 c++ 学习相关笔记 [!DANGER] 这是我的第一个电子书，更多请访问：我的vuepress主页 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-05 17:02:48 "},"chapter1/":{"url":"chapter1/","title":"C++ 介绍","keywords":"","body":"什么是 C++ C++ 的开发环境及相关工具 C++ 的编译 / 链接模型 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-20 16:51:46 "},"chapter1/0.html":{"url":"chapter1/0.html","title":"什么是 C++","keywords":"","body":"什么是 C++ 一门流行的语言 C 语言的扩展 关注性能 与底层硬件紧密结合（eg：不同硬件存储 - 大端法小端法） 对象生命周期的精准控制（由程序员自己来把握对象的销毁，不需要系统提供额外的处理机制（垃圾回收机制），从而提升了性能。） Zero-overhead Abstraction（不需要为没有使用的语言特性付出成本，eg：虚函数） 引入大量特性，便于工程实践 三种编程范式：面向过程、面向对象、泛型 函数重载、异常处理、引用 一系列不断衍进的标准集合 C++98/03 ， C++11 ， C++14 ， C++17 ， C++20 ， C++23 ? 语言本身的改进 Memory Model Lambda Expression 标准库的改进 type_traits / ranges auto_ptr C++ 标准的工业界实现 MSVC（VStudio） / GCC / Clang... 每个编译器可能并不完全遵照标准 https://godbolt.org/z/cKMjK3 不同的实现存在差异 https://godbolt.org/z/6hnPhY 不能脱离具体的语境讨论 C++ 编写程序时要注重 性能 标准 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-23 09:48:59 "},"chapter1/1.html":{"url":"chapter1/1.html","title":"C++ 的开发环境及相关工具","keywords":"","body":"C++ 的开发环境及相关工具 Visual C++ / GCC (G++) / Clang (Clang++)... 集成开发环境: Visual Studio / CodeLite / Code::blocks / Eclipse... 工具 /usr/bin/time 在 Linux 中记录程序运行事件等信息可使用 /usr/bin/time yian@yian:~$ /usr/bin/time sleep 1 # 0.00user 0.00system 0:01.00elapsed 0%CPU (0avgtext+0avgdata 2412maxresident)k # 0inputs+0outputs (0major+78minor)pagefaults 0swaps valgrind cpp reference Compiler explorer：支持多编译器和30多种编程语言，实时浏览编译后的汇编代码 C++ insights：从编译器视角去看 c++ 的源码 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-24 23:24:15 "},"chapter1/2.html":{"url":"chapter1/2.html","title":"C++ 的编译 / 链接模型","keywords":"","body":"C++ 的编译 / 链接模型 简单的加工模型 - 源程序 -> 加工 -> 可执行文件 -> 问题：无法处理大型程序 加工耗时长 即使少量修改，也需要全部重新加工 解决方案：分块处理 - 源文件 1 -> 编译 -> 目标文件 1 -> 链接 -> 可执行程序 -> - 源文件 N -> 编译 -> 目标文件 N -> 好处： 编译耗资源但一次处理输入较少 链接输入较多但处理速度较快 便于程序修改升级 由 “分块处理” 衍生出的概念 “分块处理” 衍生出的概念 定义 / 声明 头文件 / 源文件 翻译单元 源文件 + 相关头文件(直接 / 间接) - 应忽略的预处理语句 一处定义 原则： 程序级：一般函数 翻译单元级：内连函数、类、模板 编译链接流程 预处理 将源文件转换为翻译单元的过程 防止头文件被循环展开：#ifdef 解决方案，#pragma once 解决方案 两种方案对比： #ifndef 方式受 C/C++ 语言标准的支持，不受编译器的任何限制 #pragma once 方式有些编译器不支持(较老编译器不支持，如GCC 3.4版本之前不支持) #ifndef 可以针对一个文件中的部分代码，而 #pragma once 只能针对整个文件 #ifndef 更加灵活，兼容性好，#pragma once 操作简单，效率高。 #include #define KEY // 定义一个预处理宏 #define VALUE #undef YIAN // #undef 取消宏的定义 using std::cout; using std::endl; int main() { int a, b, c; a = 10, b = 20, c = 30; // defined 判断某个宏是否被定义 ,与#if, #elif配合使用 #if defined(VALUE) // 编译预处理中的条件命名，相当于 if 语句 cout #pragma once 指令，在想要保护的文件开头写入 #pragma once // code 预处理，生成预处理文件 main.i（翻译文件） g++ -E ./main.cpp -o ./main.i 编译 将翻译单元转换为相应的汇编语言表示 编译优化 https://godbolt.org/z/zh9aqx 增量编译 V.S. 全部编译 编译，生成汇编代码 g++ main.i -S -o main.s 汇编 通过汇编代码生成相应的目标文件（机器码） g++ main.s -c -o main.o 链接 合并多个目标文件，关联声明与定义 连接( Linkage )种类：内部连接、外部连接、无连接 链接常见错误：找不到定义 [!TIP] C++ 的编译 / 链接过程是复杂的,预处理、编译与链接都可能出错，编译可能产生警告、错误,都要重视 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-18 14:30:24 "},"chapter2/":{"url":"chapter2/","title":"C++ 初探","keywords":"","body":"从 Hello World 谈起 系统 I/O 猜数字与控制流 结构体与自定义数据类型 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-20 16:55:38 "},"chapter2/0.html":{"url":"chapter2/0.html","title":"从 Hello World 谈起","keywords":"","body":"从 Hello World 谈起 函数：一段能被复用的代码，可以接收输入，进行处理并（或）产生输出 返回类型：表示函数的返回结果，可以是 void 函数名：用于函数调用 形参列表：表示函数接收的参数类型，可以为空。可以为 void，可以无形参 函数体：具体执行逻辑 #include // void fun(const char* pInfo, int pValue) void fun(const char* pInfo, int /* pValue */) // 不改变接口参数数量，又避免了第二个参数误用 { std::cout main 函数：特殊的函数作为整个程序的入口 返回类型为 int， 表示程序的返回值，通常用 0 表示正常返回 形参列表可以为空 [!TIP] 在 Linux 中可以通过以下命名获取程序运行时 main 函数的返回值 echo $? # 获取被操作系统记录的返回值 # 0 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-20 16:52:27 "},"chapter2/1.html":{"url":"chapter2/1.html","title":"系统 I/O","keywords":"","body":"系统 I/O iostream 标准库提供的 IO 接口，用于与用户交互 输入流：cin ， 输出流：cout 、cerr 、clog 输入流与输出流的区别：1. 输出目标，2. 是否立即刷新缓冲区 cerr 立即刷新缓冲区 cout 、clog 不会立即刷新缓冲区（程序运行速度会快，刷新缓冲区会消耗性能） [!TIP] 对于缓冲区，比如你的程序在运行过程中出现不可预估的错误，你肯定希望它能及时的打印错误之前的输出，这时候就需要使用立即刷新缓冲区的输出方式来输出 缓冲区与缓冲区刷新：std::flush; std::endl; \\n 换行，但不会刷新缓冲区，std::endl 会刷新缓冲区 #include // <> 表示在系统环境变量中查找 #include \"alloca.h\" // 双口号表示从工程文件所在位置查找 int main() { std::cout 对于以上程序我们可以使用以下方法： ./output > txt1 2> txt2 这样我们可以看到 txt1 中保存了 cout 的输出结果，txt2 保存了 cerr clog 输出的结果 名字空间 防止名称冲突 std ：名字空间 访问名字空间中的元素的三种方法：域解析符 ::，using 语句，名字空间别名 名字空间与名称改编（name mangling） 在 linux 中 使用 nm IO.o 查看 IO.o 文件，可以发现编译器将相同的函数名进行了处理（名字改编 name mangling）， （demangling）使用 nm IO.o | c++filt -t 直观的查看 #include namespace Space1 { void fn() { } } namespace Space2 { void fn() { } } int main() { Space1::fn(); Space2::fn(); namespace Space = Space1; // 名字空间别名 } [!WARNING] 一般不在主函数前面以 using namespace Space1 方式使用名字空间，特别是在头文件中，这样有名字冲突的风险，放在主函数中也会有风险，最保险的写法是 :: C/C++ 系统IO比较 printf：使用直观，但容易出错 cout：不容易出错，但书写冗长 C++ 20格式化库：新的解决方案 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-18 14:08:21 "},"chapter2/2.html":{"url":"chapter2/2.html","title":"猜数字与控制流","keywords":"","body":"猜数字与控制流 if 语句：用于分支选择 条件部分：用于判断是否执行 语句部分：要执行的操作 == 与 = 操作 = 操作：用于赋值,将数值保存在变量所对应的内存中 == 操作：用于判断两个值是否相等 可以将常量放在 == 左边以防止误用 while 语句：用于循环执行 条件部分：用于判断是否执行 语句部分：要执行的操作 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-18 14:31:20 "},"chapter2/3.html":{"url":"chapter2/3.html","title":"结构体与自定义数据类型","keywords":"","body":"结构体与自定义数据类型 结构体：将相关的数据放置在一起 可以通过点操作符 . 访问内部元素 可以作为函数的输入参数或返回类型 可以引入成员函数，更好地表示函数与数据的相关性 #include struct Point { int x; float y; void Incx() { } } void fun(Point p) { /* code... */ } int main() { Point p; p.x = 10; p.y = 2.1; p.Incx(); } Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-18 14:31:32 "},"chapter3/":{"url":"chapter3/","title":"对象与基本类型","keywords":"","body":"从初始化 / 赋值语句谈起 类型详述 复合类型 常量类型与常量表达式 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-20 23:16:33 "},"chapter3/0.html":{"url":"chapter3/0.html","title":"从初始化 / 赋值语句谈起","keywords":"","body":"从初始化 / 赋值语句谈起 初始化 / 赋值语句是程序中最基本的操作，其功能是将某个值与一个对象关联起来 值：字面值、对象(变量或常量)所表示的值 ...... 标识符：变量、常量、引用 ...... 初始化基本操作： 在内存中开辟空间，保存相应的数值 在编译器中构造符号表，将标识符与相关内存空间关联起来 值与对象都有类型 初始化 / 赋值可能涉及到类型转换 int x = 10.5; int y(10); int z = x; Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-20 17:03:24 "},"chapter3/1.html":{"url":"chapter3/1.html","title":"类型详述","keywords":"","body":"类型详述 类型是一个编译期概念，可执行文件中不存在类型的概念 C++ 是强类型语言 引入类型是为了更好地描述程序，防止误用 类型描述了： 存储所需要的尺寸 (sizeof ，标准并没有严格限制 ) #include int main() { std::cout 取值空间 (std::numeric_limits ，超过范围可能产生溢出 ) #include #include int main() { std::cout ::min() ::max() ::min() ::max() 内存溢出，在编写程序时候需要注意避免 #include #include int main() { unsigned int x = std::numeric_limits::min(); x = x - 1; std::cout ::max(); y = y + 1; std::cout 对齐信息( alignof ：输出类型的对齐信息)，有了对齐信息可以让 CPU 很快的找到数据 #include #include int main() { int x = 10; std::cout 对齐：比如将 x 存在 7999 ~ 8003， 比如系统从 8000 开始读，每次读取 64 位，没对齐则需要先从 8000-64 ~ 7999，在从 8000 ~ 8063，读取两次才能完整的读取到 x，但是如果对齐到 8000，从 8000 开始读取则一次就可以读取到 x 可以执行的操作 类型划分 类型可以划分为基本类型与复杂类型 基本（内建）类型： C++ 语言中所支持的类型 数值类型 字符类型（char， wchar_t， char16_t， char32_t） 整数类型 带符号整数类型：short， int， long， long long 无符号整数类型：unsigned + 带符号整数类型 浮点类型 float， double， long double void 复杂类型：由基本类型组合、变种所产生的类型，可能是标准库引入，或自定义类型 [!DANGER] 与类型相关的标准未定义部分 char 是否有符号，我们可以在定义时指定 #include int main() { char ch1; unsigned char ch2; signed char ch3; } 整数中内存中的保存方式：大端 小端（涉及到网络传输时候需要考虑，不然传过来就是相反的了） 0x100 0x101 0x102 0x103 01 23 45 67 Big Endian 0x100 0x101 0x102 0x103 67 45 23 01 Little Endian 每种类型的大小(间接影响取值范围) C++11 中引入了固定尺寸的整数类型，如 int32_t 字面值及其类型 字面值：在程序中直接表示为一个具体数值或字符串的值，每个字面值都有其类型 整数字面值： 20 (十进制)， 024 (八进制)， 0x14 (十六进制) -- int 型 浮点数： 1.3 ， 1e8 – double 型 字符字面值： 'c'， '\\n'， '\\x4d' – char 型 字符串字面值： \"Hello\" – char[6] 型 布尔字面值： true， false – bool 型 指针字面值： nullptr – nullptr_t 型 可以为字面值引入前缀或后缀以改变其类型 1.3 ( double ) -- 1.3f ( float ) 2 ( int ) -- 2ULL (unsigned long long) [!TIP] 可以引入自定义后缀来修改字面值类型（下面的 _dd 就是用户的自定义类型） #include int operator \"\" _dd(long double x) { return (int)x * 2; } int main() { int x = 3.14_dd; std::cout 变量及其类型 变量：对应了一段存储空间，可以改变其中内容 变量的类型在其首次声明（定义）时指定： int x ：定义一个变量 x ，其类型为 int 变量声明与定义的区别： extern 前缀（表示变量是从外部引入的） 变量的初始化与赋值 初始化：在构造变量之初为其赋予的初始值 缺省初始化（比如在函数内部的赋随机值，全局变量线程局部变量等赋初始值） 直接 / 拷贝初始化（本质相同） 其它初始化 int x = 10; // 拷贝初始化 int y(10); // 直接初始化 int z{10}; // 直接初始化 注意：如果使用 extern 声明一定不能初始化，这样会重复定义 extern int g_x = 10; // error 赋值：修改变量所保存的数值 （隐式）类型转换 为变量赋值时可能涉及到类型转换 bool 与 整数之间的转换 浮点数与整数之间的类型转换 隐式类型转换不只发生在赋值时 if判断 数值比较 无符号数据与带符号数据之间的比较 std::cmp_XXX ( C++ 20 ) #include int main() { int y = 'c'; std::cout Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-18 20:18:30 "},"chapter3/2.html":{"url":"chapter3/2.html","title":"复合类型","keywords":"","body":"复合类型：从指针到引用 指针：一种间接类型 特点： 可以指向不同的对象 具有相同的尺寸 [!TIP] 无论指针指向什么类型的数据，指针的尺寸都是相同的，因为指针指向的是所指向数据在内存中存储的首地址。 相关操作 & - 取地址操作符（&42 是无效的，42是右值没有地址） * - 解引用操作符（对 0 地址解引用会报错） 指针对应指向内存的首地址（0x1234） 0x5678 0x1234 0x1234 -> 42 int* p = &val int val = 42 指针的定义 int* p; // 未赋初值的指针的不确定的，危险的 int* p = &val; int* p = nullptr; 关于 nullptr 一个特殊的对象（类型为 nullptr_t），表示空指针 类似于 C 中的 NULL ，但更加安全 指针与 bool 的隐式转换：非空指针可以转换为 true ;空指针可以转换为 false 指针的主要操作：解引用;增加、减少;判等 void* 指针 没有记录对象的尺寸信息，可以保留任意地址 支持判等操作 不要使用 void* 来进行加减，因为它已经丢失了尺寸信息 void fun(void* param) { } int main() { int* x = nullptr; char* y = nullptr; fun(x); fun(y); } 指针的指针 0xabcd 0x5678 0x1234 0x5678 -> 0x1234 -> 42 int** pp = &p int*p = &val int val = 42 指针 V.S. 对象：指针是对象的间接引用，降低成本。 指针复制成本低，读写成本高 struct Str { // ... 一个很大的结构体 } void fun (Str param) { } int main() { Str x; fun(x); } 调用函数的时候需要将这个结构体复制到函数的形参上，这很消耗性能，我们可以使用指针来进行改进，只传入结构体的指针即可。 void fun (Str* param) { } int main() { Str x; Str* p = &x; fun(p); } 指针的问题 可以为空 地址信息可能非法 解决方案：引用 引用 int& ref = val 是对象的别名，不能绑定字面值 构造时绑定对象，在其生命周期内不能绑定其它对象（赋值操作会改变对象内容） 不存在空引用，但可能存在非法引用——总的来说比指针安全 属于编译期概念，在底层还是通过指针实现 #include int main() { int x = 3; int& ref = x; std::cout 指针的引用 指针是对象，因此可以定义引用 int* p = &val; int* & ref = p; 类型信息从右向左解析 #include int main() { int x = 3; int* ptr = &x; int*& ref = ptr; // 类型信息从右向左解析 int& ref2 = x; } Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-20 21:24:33 "},"chapter3/3.html":{"url":"chapter3/3.html","title":"常量类型与常量表达式","keywords":"","body":"常量类型与常量表达式 常量与变量相对，表示不可修改的对象 使用 const 声明常量对象 是编译期概念，编译器利用其 防止非法操作 优化程序逻辑 常量指针与顶层常量（top-level const） const int* p; #include int main() { int x = 3; const int* ptr = &x; *ptr = 4; // error: assignment of read-only location '* ptr' } int* const p; int x = 3; int* const ptr = &x; int y = 0; ptr = &y; // error: assignment of read-only variable 'ptr' const int* const p; 常量指针可指向变量 int x = 3; // &x; int* --> const int* const int* ptr = &x; ptr = 20; // error: invalid conversion from 'int' to 'const int*' const int x = 3; // const int* --> int* int* ptr = &x; // error: invalid conversion from 'const int*' to 'int*' 常量引用（也可绑定变量） const int& 可读但不可写 主要用于函数形参 可以绑定字面值 const int& ref = 10;， int& ref = 10是不行的error: cannot bind non-const lvalue reference of type 'int&' to an rvalue of type 'int' struct Str { // ... } void fun(const Str& param) { param = ...;// 不使用 const Str& 则在函数中修改 param 会影响 x 的值 // 直接使用 Str* param 有可能参数传递的指针非法或为空 } int main() { Str x; fun(x); } 常量表达式（从 C++11 开始） 使用 constexpr 声明 声明的是编译期常量 编译器可以利用其进行优化 #include int main() { int x; std::cin >> x; const int y1 = x; // constexpr int y1 = x; // error: the value of 'x' is not usable in a constant expression constexpr int y2 = 3; // const int y2 = 3; if(y1 == 2) { } if(y2 ==3) { } } 常量表达式指针: constexpr 位于 * 左侧，但表示指针是常量表达式 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-23 15:44:47 "},"chapter3/4.html":{"url":"chapter3/4.html","title":"类型别名与类型的自动推导","keywords":"","body":"类型别名与类型的自动推导 可以为类型引入别名，从而引入特殊的含义或便于使用（如： size_t）。两种引入类型别名的方式 typedef int MyInt; using MyInt = int; (从 C++11 开始) #include typedef int Myint; int main() { Myint x = 3; } 使用 using 引入类型别名更好 typedef char MyCharArr[4]; using MyCharArr = char[4]; [!TIP] 类型别名与指针、引用的关系： 应将指针类型别名视为一个整体，在此基础上引入常量表示指针为常量的类型 不能通过类型别名构造引用的引用 类型的自动推导 从 C++11 开始，可以通过初始化表达式自动推导对象类型 自动推导类型并不意味着弱化类型，对象还是强类型 自动推导的几种常见形式 auto：最常用的形式,但会产生类型退化 auto x = 3; auto z(3.5); auto y; // error: declaration of 'auto y' has no initializer 类型退化： int x = 3; int& ref = x; int y = ref; // int& 类型退化为 int 类型 int a = 5; const int& rex = a; int b = rex; // const int& -> int 以下例子证明了 auto 的类型退化 #include #include int main() { int x = 4; int& ref = x; auto req = ref; // int& -> int std::cout const auto / constexpr auto： 推导出的是常量 / 常量表达式类型 auto& ： 推导出引用类型,避免类型退化 #include #include int main() { const int x = 3; auto& y = x; std::cout int z: const auto -> const int std::cout decltype(exp) ：返回 exp 表达式的类型（左值加引用） decltype(val) ：返回 val 的类型 #include #include int main() { int x = 4; int& y1 = x; auto y2 = y1; decltype(y1) y3 = y1; // 没有类型退化 std::cout decltype(auto) ：从 c++14 开始支持,简化 decltype 使用 concept auto：从 C++20 开始支持,表示一系列类型( std::integral auto x = 3; ) #include #include #include #include int main() { decltype(3.5 + 13l) x = 3.5 + 13l; decltype(auto) y = 1.2 + 22l; std::integral auto z = 3; std::cout Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-24 00:49:53 "},"chapter3/5.html":{"url":"chapter3/5.html","title":"域与对象的生命周期","keywords":"","body":"域与对象的生命周期 域 （scope） 表示了程序中的一部分，其中的名称有唯一的含义 全局域（ global scope ）：程序最外围的域，其中定义的是全局对象 块域（ block scope ），使用大括号所限定的域，其中定义的是局部对象 还存在其它的域：类域，名字空间域...... 域可以嵌套，嵌套域中定义的名称可以隐藏外部域中定义的名称 对象的生命周期起始于被初始化的时刻，终止于被销毁的时刻 #include int x = 3; int main() { int x = 5; std::cout [!TIP] 通常来说 全局对象的生命周期是整个程序的运行期间。 局部对象生命周期起源于对象的初始化位置，终止于所在域被执行完成 #include int x = 3; int main() { int x = 5; { std::cout Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-11-24 01:02:57 "},"chapter4/":{"url":"chapter4/","title":"数组、 vector 与字符串","keywords":"","body":"数组 vector string Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 14:57:57 "},"chapter4/1.html":{"url":"chapter4/1.html","title":"数组","keywords":"","body":"数组 数组：将一个或多个相同类型的对象串连到一起，所组成的类型 数组的初始化方式： 缺省初始化 int a[2]; 聚合初始化 int b[2] = {1, 2}; #include #include int main() { int b[3] = {}; // 初始化为零 int c[3] = {1, 2}; // 1, 2, 0 int d[] = {1, 2, 3}; std::cout 注意 不能用 auto 来声明数组类型 #include #include int main(int argc, char **argv) { auto a = {1, 3, 4}; std::cout cd Debug && ./demo | c++filt -t ：std::initializer_list 这个就是使用 auto 定义的数组类型 数组不能复制 元素个数必须是一个常量表达式（编译期可计算的值） int a; // int int b[10]; // int[10] int x; int c[x]; // int[x] 可变长度数组不支持，有些编译器的扩展可以，但是程序的可扩展性就丧失了 字符串数组的特殊性（字符串以 \\0 来标志着字符串结束） char str[] = \"Hello\"; char str2[] = {'H', 'e', 'l', 'l', 'o', '\\0'}; std::cout ::value 数组的复杂声明 指针数组与数组的指针 #include #include #include int main(int argc, char **argv) { int x1; int x2; int x3; int* a[3] = {&x1, &x2, &x3}; std::cout ::value ::value 声明数组的引用 #include #include int main(int argc, char **argv) { int b[3]; int (&a)[3] = b; std::cout ::value 数组中的元素访问 数组对象是一个左值 #include #include int main(int argc, char **argv) { int a[3] = {1, 2, 3}; // a: l-value std::cout ::value ::value ::value 使用时通常会转换成相应的指针类型 x[y] → *((x) + (y)) #include #include int main(int argc, char **argv) { int a[3] = {1, 2, 3}; auto b = a; std::cout ::value 从数组到指针 数组到指针的隐式转换 使用数组对象时，通常情况下会产生数组到指针的隐式转换 隐式转换会丢失一部分类型信息 #include int main(int argc, char **argv) { int a[3] = {1, 2, 3}; // int[3] std::cout 可以通过声明引用来避免隐式转换 auto& b = a; // int(&)[3] 120 64~67 68~71 72~75 76~79 64 --> 0 1 2 3 pointer array 注意：不要使用 extern 指针来声明数组 Unknown Bounded Array 声明 #include extern int* array; int main(int argc, char **argv) { std::cout 获得指向数组开头与结尾的指针 : std::(c)begin, std::(c)end #include #include int main(int argc, char **argv) { int a[3] = {1, 2, 3}; std::cout 指针算数： 增加、减少 比较 求距离 解引用 指针索引 其他操作 求元素的个数 sizeof 方法 std::size 方法，在 gcc 8.2.0 中不是 std 的成员 (c)end - (c)begin 方法 #include int main(int argc, char **argv) { int a[3]; std::cout 元素遍历 基于元素个数 基于 (c)begin/(c)end #include int main(int argc, char **argv) { int a[4] = {2, 3, 4, 7}; auto ptr = std::cbegin(a); while (ptr != std::cend(a)) { std::cout 基于 range-based for 循环（语法糖） #include int main(int argc, char **argv) { int a[4] = {2, 3, 4, 7}; for (int x : a) { std::cout 使用 C++ Insights 翻译为： #include int main(int argc, char ** argv) { int a[4] = {2, 3, 4, 7}; { int (&__range1)[4] = a; int * __begin1 = __range1; int * __end1 = __range1 + 4L; for(; __begin1 != __end1; ++__begin1) { int x = *__begin1; std::cout.operator C 字符串 C 字符串本质上也是数组 C 语言提供了额外的函数来支持 C 字符串相关的操作 ： strlen, strcmp… #include #include int main(int argc, char **argv) { char str[] = \"Hello\"; auto ptr = str; // char* std::cout [!TIP] 使用 strlen 来计算 {'H', 'e', 'l', 'l', 'o'} 的结果是不确定的，因为它是看到 \\0 才算结尾，不然会一直往上累计。 多维数组 本质：数组的数组 int a[3][4]; #include #include int main(int argc, char **argv) { int x1[3]; int x2[3][4]; // (int int int int) (int int int int) (int int int int) std::cout ::value 多维数组的聚合初始化：一层大括号 V.S. 多层大括号 int x1[3][4] = {1, 2, 3, 4, 5}; int x2[3][4] = {{1, 2, 3, 4}, {4, 5, 6}}; 多维数组的索引与遍历 使用多个中括号来索引 使用多重循环来遍历 #include int main(int argc, char **argv) { int x1[3][4] = {1, 2, 3, 4, 5}; for (auto& x : x1) // 不使用引用则 x 会隐式转换为指针类型而无法使用 range-based for 循环 // 可以将其放入 C++ Insights 中查看原因 { for (auto y : x) { std::cout 指针与多维数组 多维数组可以隐式转换为指针，但只有最高维会进行转换，其它维度的信息会被保留 #include int main() { int x[3][4]; auto ptr = x; // int (*ptr)[4] = x; int x2[3][4][5]; auto ptr1 = x2; // int (*ptr1)[4][5] = x2; auto ptr2 = ptr1[0]; // int (*ptr2)[5] = ptr1[0]; } 使用类型别名来简化多维数组指针的声明 #include using A2 = int[4][5]; int main() { int x[3][4][5]; A2* ptr = x; // A2 (*ptr) = x; auto ptr1 = ptr[0]; // int (*ptr1)[5] = ptr[0]; A2 x1[3]; } 使用指针来遍历多维数组 #include int main() { int x2[3][4] = {}; auto ptr = std::begin(x2); while (ptr != std::end(x2)) { auto ptr2 = std::begin(*ptr); while (ptr2 != std::end(*ptr)) { std::cout Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-21 23:59:40 "},"chapter4/2.html":{"url":"chapter4/2.html","title":"vector","keywords":"","body":"vector vector 是 C++ 标准库中定义的一个类模板 与内建数组相比，更侧重于易用性 可复制、可在运行期动态改变元素个数 构造与初始化 聚合初始化 其它的初始化方式 #include #include int main() { std::vector x = {1, 2, 3}; std::vector y(3); y = x; std::vector z1 = {1, 1, 1}; std::vector z2(3, 1); // = z1 } 其它方法 获取元素个数、判断是否为空 插入、删除元素 vector 的比较 #include #include int main() { std::vector x = {1, 2, 3}; std::cout x1 = {1, 2, 3}; std::cout vector 中元素的索引与遍历 [] V.S. at (c)begin / (c)end 函数 V.S. (c)begin / (c)end 方法 #include #include int main() { std::vector x = {1, 2, 3}; std::cout 迭代器 模拟指针的行为 包含多种类别，每种类别支持的操作不同 vector 对应随机访问迭代器 解引用与下标访问 移动 两个迭代器相减求距离 x.end() - x.begin() 两个迭代器比较 vector 相关的其它内容 添加元素可能使迭代器失效 多维 vector #include #include int main() { std::vector> x; x.push_back(std::vector()); x[0].push_back(1); std::cout > y{{1, 2, 3}, {4, 5, 6}}; std::cout 从 . 到 -> 操作符 #include #include int main() { std::vector x; std::cout * ptr = &x; std::cout size() vector 内部定义的类型 size_type iterator / const_iterator Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 11:57:05 "},"chapter4/3.html":{"url":"chapter4/3.html","title":"字符串","keywords":"","body":"string 是 C++ 标准库中定义的一个类模板特化别名，用于内建字符串的代替品 与内建字符串相比，更侧重于易用性 可复制、可在运行期动态改变字符个数 构造与初始化 其它方法 尺寸相关方法（ size / empty ） 比较 赋值 拼接 索引 转换为 C 字符串 #include #include int main() { std::string x = \"Hello world\"; std::string y = x; y = y + \" !\"; std::string a(3, 'a'); std::cout #include #include int main() { std::string x(\"Hello\"); auto ptr = x.c_str(); std::cout Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 14:57:27 "},"chapter5/":{"url":"chapter5/","title":"表达式","keywords":"","body":"表达式基础 表达式详述 C++ 17 对表达式的求值顺序限定 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-22 15:50:02 "},"chapter5/1.html":{"url":"chapter5/1.html","title":"表达式基础","keywords":"","body":"表达式基础 表达式由一到多个操作数组成，可以求值并 ( 通常会 ) 返回求值结果 最基本的表达式：变量、字面值 通常来说，表达式会包含操作符（运算符） 操作符的特性 接收几个操作数：一元、二元、三元 操作数的类型 类型转换 操作数是左值还是右值 结果的类型 结果是左值还是右值 优先级与结合性 cpp-reference ，可以通过小括号来改变运算顺序 操作符的重载 不改变接收操作数的个数、优先级与结合性 操作数求值顺序的不确定性 #include void fun(int p1, int p2) { std::cout arg1 * x = x + 1 -> arg2 * p1 = arg1 * p2 = arg2 */ } 左值与右值 传统的左值与右值划分 来源于 C 语言：左值可能放在等号左边；右值只能放在等号右边 在 C++ 中，左值也不一定能放在等号左边；右值也可能放在等号左边 所有的划分都是针对表达式的，不是针对对象或数值 glvalue（泛左值） ：标识一个对象、位或函数 prvalue （纯右值）：用于初始化对象或作为操作数（int() ...） xvalue （亡值）：表示其资源可以被重新使用 cpp reference - 值类别 expression | | glvalue rvalue | | | lvalue xvalue prvalue 左值与右值的转换 左值转换为右值（ lvalue to rvalue conversion ） int x = 3; int y = x; 临时具体化（ Temporary Materialization ） struct Str { int x; } int main() { std::cout 再论 decltype prvalue → type decltype(3) x; // int x; lvalue → type& int x; decltype((x)) y = x; // int & y = x; xvalue → type&& #include #include int main() { int x; // 使用 std::move() 构造将亡值 decltype(std::move(x)) y = std::move(x); // int && y = std::move(x); } 类型转换 一些操作符要求其操作数具有特定的类型，或者具有相同的类型，此时可能产生类型转换 隐式类型转换 自动发生 实际上是一个（有限长度的）转型序列 https://en.cppreference.com/w/cpp/language/implicit_conversion 显式类型转换 显式引入的转换 static_cast #include int main() { std::cout (y)) const_cast #include int main() { int x = 3; const int& ref = x; int& ref2 = const_cast(ref); ref2 = 4; std::cout dynamic_cast reinterpret_cast C 形式的类型转换 (double)3; Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-24 22:25:38 "},"chapter5/2.html":{"url":"chapter5/2.html","title":"表达式详述","keywords":"","body":"表达式详述 算术操作符 共分为三个优先级 + ， - （一元） *， / ，% + ， - （二元） 均为左结合的 通常来说，操作数与结果均为算数类型的右值；但加减法与一元 + 可接收指针 #include int main() { int a[3] = {1, 2, 3}; auto b = a; // int * b = a; auto& c = a; // int (&c)[3] = a; const auto& d = a; // const int (&d)[3] = a; const auto& e = +a; // int *const & e = +a; } 一元 + 操作符会产生 integral promotion #include int main() { short x = 3; auto y = +x; // int y = +static_cast(x); } 整数相除会产生整数，向 0 取整 求余只能接收整数类型操作数，结果符号与第一个操作数相同 满足 (m / n) * n + m % n == m std::cout 逻辑与关系操作符 关系操作符接收算术或指针类型操作数；逻辑操作符接收可转换为 bool 值的操作数 操作数与结果均为右值（结果类型为 bool ） 除逻辑非外，其它操作符都是左结合的 逻辑与、逻辑或具有短路特性 #include int main() { int ptr = nullptr; if (ptr && (*ptr == 3)) // ptr 为空则不会对后面的 (*ptr == 3) 进行处理（短路） { // ... } } 逻辑与的优先级高于逻辑或：a || b && c 通常来说，不能将多个关系操作符串连 std::cout 4 > 3) 4 -> True // 2. True > 3 -> 1 > 3 // 3. 1 > 3 -> 0 不要写出 val == true 这样的代码 #include int main() { int a = 2; if (a == true) //等于：if (a == 1) { std::cout Spaceship operator: strong_ordering：auto res = (3 5) weak_ordering partial_ordering：auto res = (3.0 5.0) #include int main() { // if (a > b) { // } // else if (a b) // std::strong_ordering res = (a b); if (res > 0) { } else if (res 位操作符 接收右值，进行位运算，返回右值 除取反外，其它运算符均为左结合的 #include int main() { signed char x = 3; // 0000 0011 signed char y = 5; // 0000 0101 std::cout -4 std::cout 1 std::cout 7 std::cout 6 } 注意计算过程中可能会涉及到 integral promotion signed char x = 3; auto y = ~x; // int y = ~static_cast(x); signed char z = 4; auto t = x & z; // int t = static_cast(x) & static_cast(z) 注意这里没有短路逻辑 移位操作在一定情况下等价于乘（除） 2 的幂，但速度更快 #include int main() { signed char x = 3; // 0000 0011 std::cout 6 std::cout > 1) 1 signed char y = -4; // 1111 1100 std::cout -8 std::cout > 1) -2 } 注意整数的符号与位操作符的相关影响 integral promotion 会根据整数的符号影响其结果 右移保持符号，但左移不能保证 #include int main() { unsigned char x = 0xff; // 1111 1111 auto y = ~x; std::cout 赋值操作符 左操作数为可修改左值；右操作数为右值，可以转换为左操作数的类型 赋值操作符是右结合的 求值结果为左操作数 可以引入大括号（初始化列表：x = { y };）以防止收缩转换（ narrowing conversion ） 小心区分 = 与 == 复合赋值运算符 #include int main() { int x = 2; int y = 3; // 交换两值并不引入额外的内存 x^=y^=x^=y; std::cout 自增与自减运算符 ++; -- 分前缀与后缀两种情况 操作数为左值；前缀时返回左值；后缀时返回右值 建议使用前缀形式 #include int main() { int x = 3; int y; y = x++; std::cout 其它操作符 成员访问操作符： . 与 -> -> 等价于 (*). . 的左操作数是左值（或右值），返回左值（或右值 xvalue ） -> 的左操作数指针，返回左值 #include struct Str { int x = 1; }; int main() { Str a; std::cout x 条件操作符 唯一的三元操作符 接收一个可转换为 bool 的表达式与两个类型相同的表达式，只有一个表达式会被求值 如果表达式均是左值，那么就返回左值，否则返回右值 右结合 #include int main() { int x = 1; int y = 2; true ? (++x) : (++y); std::cout 0) ? 1 : (score == 0) ? 0 : -1; std::cout 逗号操作符 确保操作数会被从左向右求值：std::cout 求值结果为右操作数 左结合 sizeof 操作符 操作数可以是一个类型或一个表达式 并不会实际求值，而是返回相应的尺寸 std::cout 域解析操作符 :: #include int x = 4; int main() { int x = 5; std::cout 函数调用操作符 () 索引操作符 [] 抛出异常操作符 throw ... Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-26 10:07:13 "},"chapter5/3.html":{"url":"chapter5/3.html","title":"C++ 17 对表达式的求值顺序限定","keywords":"","body":"C++ 17 对表达式的求值顺序限定 以下表达式在 C++17 中，可以确保 e1 会先于 e2 被求值 e1[e2] e1.e2 e1.*e2 e1→*e2 e1 e1>>e2 e2 = e1 / e2 += e1 / e2 *= e1… （赋值及赋值相关的复合运算） new Type(e) 会确保 e 会在分配内存之后求值 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-24 23:00:16 "},"chapter6/":{"url":"chapter6/","title":"语句","keywords":"","body":"语句基础 分支语句 循环语句 语句的综合应用——达夫设备 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-26 10:25:20 "},"chapter6/1.html":{"url":"chapter6/1.html","title":"语句基础","keywords":"","body":"语句基础 语句的常见类别 表达式语句：表达式后加分号，对表达式求值后丢弃，可能产生副作用 空语句：仅包含一个分号的语句，可能与循环一起工作 复合语句（语句体）：由大括号组成，无需在结尾加分号，形成独立的域（语句域） #include int main() { ; int x = 2; { int x = 3; } } 顺序语句与非顺序语句 顺序语句 从语义上按照先后顺序执行 实际的执行顺序可能产生变化（编译器优化、硬件乱序执行） 与硬件流水线紧密结合，执行效率较高 非顺序语句 在执行过程中引入跳转，从而产生复杂的变化 分支预测错误可能导致执行性能降低 最基本的非顺序语句： goto 通过标签指定跳转到的位置 具有若干限制 不能跨函数跳转 void fun () { goto label; } int main() { label: std::cout 向前跳转时不能越过对象初始化语句 goto label; int y = 1; label: y = y + 1; 向后跳转可能会导致对象销毁与重新初始化 #include int main() { bool flag = true; label: int x = 3; if (flag) { flag = false; goto label; } } goto 本质上对应了汇编语言中的跳转指令 缺乏结构性的含义 容易造成逻辑混乱 除特殊情况外，应避免使用 #include int main() { int x = 3; if (x) goto label; x += 1; label: return 0; } Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-26 11:58:37 "},"chapter6/2.html":{"url":"chapter6/2.html","title":"分支语句","keywords":"","body":"分支语句 if 语法： https://zh.cppreference.com/w/cpp/language/if 使用语句块表示复杂的分支逻辑 从 if 到 if-else 实现多重分支 else 会与最近的 if 匹配 #include int main() { int grade = 65; if (grade > 60) if (grade > 80) std::cout 使用大括号改变匹配规则 if V.S. constexpr if —— 运行期与编译期分支（可以更好的编译优化） #include int main() { constexpr int grade = 80; if constexpr (grade 带初始化语句的 if #include int main() { int x = 1; if (int y = x * 3; y > 10) { // ... } } switch 语法： https://zh.cppreference.com/w/cpp/language/switch 条件部分应当能够隐式转换为整形或枚举类型，可以包含初始化的语句 case/default 标签 case 后面跟常量表达式 ， 用于匹配 switch 中的条件，匹配时执行后续的代码 可以使用 break 跳出当前的 switch 执行（可以添加编译选项 -Wimplicit-fallthrough 来发现 fall through 的情况，避免漏掉 break） #include int main() { int x; switch (std::cin >> x; x) { case 3: std::cout default 用于定义缺省情况下的逻辑 switch (std::cin >> x; x) { case 3: std::cout 在 case/default 中定义对象要加大括号 switch (std::cin >> x; x) { case 3: { int y = 3; std::cout 两个分支共享一个逻辑（没有 fall through） #include int main() { int x; switch (std::cin >> x; x) { case 3: std::cout [[fallthrough]] 属性（C++17）：（告诉编译器不是漏掉了 break 而是就想执行完 case 3 后执行后面的语句，这样就是合法的了，不需要直接在编译器设置中进行设置了） #include int main() { int x; switch (std::cin >> x; x) { case 3: std::cout 与 if 相比的优劣 分支描述能力较弱 在一些情况下能引入更好的优化 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-29 14:08:20 "},"chapter6/3.html":{"url":"chapter6/3.html","title":"循环语句","keywords":"","body":"循环语句 while 语法： https://zh.cppreference.com/w/cpp/language/while 处理逻辑： 判断条件是否满足，如果不满足则跳出循环 如果条件满足则执行循环体 执行完循环体后转向步骤 1 #include int main() { int x = 3; while (x) { std::cout [!TIP] 注意：在 while 的条件部分不包含额外的初始化内容 do-while 语法： https://zh.cppreference.com/w/cpp/language/do 注意结尾处要有分号，表示一条语句的结束 处理逻辑： 执行循环体 断条件是否满足，如果不满足则跳出循环 如果条件满足则转向步骤 1 #include int main() { int x = 0; do { std::cout 0); // 0 } for 语法： https://zh.cppreference.com/w/cpp/language/for 处理逻辑 初始化语句会被首先执行 条件部分会被执行，执行结果如果为 false ，则终止循环 否则执行循环体 迭代表达式会被求值，之后转向 2 在初始化语句中声明多个名字 初始化语句、条件、迭代表达式可以为空- for 的更多示例 #include #include int main() { // 典型的以单语句作为循环体的循环 for (int i = 0; i v = {3, 1, 4, 1, 5, 9}; for (auto iter = v.begin(); iter != v.end(); ++iter) { std::cout 1) break; std::cout 基于范围的 for 循环 语法： https://zh.cppreference.com/w/cpp/language/range-for 本质：语法糖，编译器会转换为 for 循环的调用方式 转换形式的衍化： C++11 / C++17 / C++20 使用常量左值引用读元素；使用 万能引用（universal reference）修改元素 #include #include int main() { std::vector arr{1, 2, 3, 4, 5}; for (int v : arr) std::cout a{\"h\", \"e\", \"l\", \"l\", \"o\"}; for (const std::string& v : a) // 使用常量左值引用更加高效 // for (const auto& v : a) std::cout arr{true, false, true}; //for (auto& b : arr) // error: cannot bind non-const lvalue reference of type 'std::_Bit_reference&' to an rvalue of type 'std::_Bit_iterator::reference {aka std::_Bit_reference}' for (auto&& b : arr) // 使用万能引用而不是 auto& b = false; } break / continue 含义（转自 cpp reference ） break: 导致外围的 for 、范围 for 、 while 或 do-while 循环或 switch 语句终止 continue: 用于跳过整个 for 、while 或 do-while 循环体的剩余部分。 注意这二者均不能用于多重嵌套循环，多重嵌套循环的跳转可考虑 goto 语句 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-26 16:29:49 "},"chapter6/4.html":{"url":"chapter6/4.html","title":"语句的综合应用——达夫设备","keywords":"","body":"语句的综合应用 - 达夫设备 使用循环展开提升系统性能 处理无法整除的情形 额外增加一个循环语句 将 switch 与循环结合 -- 达夫设备 #include #include int main(void) { constexpr size_t buffer_count = 10000; std::vector buffer(buffer_count); for (size_t i = 0; i buffer[i] ? max_value : buffer[i]); } std::cout 程序大部分都用来进行循环了，循环里面求最大值显得时间占比很小，所以对此进行优化： #include #include int main(void) { constexpr size_t buffer_count = 10000; std::vector buffer(buffer_count); for (size_t i = 0; i buffer[i]) ? max_value : buffer[i]; max_value = (max_value > buffer[i+1]) ? max_value : buffer[i+1]; max_value = (max_value > buffer[i+2]) ? max_value : buffer[i+2]; max_value = (max_value > buffer[i+3]) ? max_value : buffer[i+3]; max_value = (max_value > buffer[i+4]) ? max_value : buffer[i+4]; max_value = (max_value > buffer[i+5]) ? max_value : buffer[i+5]; max_value = (max_value > buffer[i+6]) ? max_value : buffer[i+6]; max_value = (max_value > buffer[i+7]) ? max_value : buffer[i+7]; } std::cout 我们设置成一次循环里面处理8次数据，这样相对于循环占用时间就小了很多。但是，如果我们把10000改成10001，也就是不是8的倍数，这时候最大值会打印错误的数，因为最后一次循环中会越界访问数组后面的7个数据，这些数据是随机值，所以得到的结果与实际偏差较大。 对此，需要对方案进行修改，不能被8整除的部分，让它进行单独的循环，修改后如下： #include #include int main() { constexpr size_t buffer_count = 10001; std::vector buffer(buffer_count); for (size_t i = 0; i buffer[i]) ? max_value : buffer[i]; max_value = (max_value > buffer[i+1]) ? max_value : buffer[i+1]; max_value = (max_value > buffer[i+2]) ? max_value : buffer[i+2]; max_value = (max_value > buffer[i+3]) ? max_value : buffer[i+3]; max_value = (max_value > buffer[i+4]) ? max_value : buffer[i+4]; max_value = (max_value > buffer[i+5]) ? max_value : buffer[i+5]; max_value = (max_value > buffer[i+6]) ? max_value : buffer[i+6]; max_value = (max_value > buffer[i+7]) ? max_value : buffer[i+7]; } for (size_t i = buffer_count / 8 * 8; i buffer[i] ? max_value : buffer[i]; } std::cout 可以使用指针对代码进行优化 #include #include int main() { constexpr size_t buffer_count = 10001; std::vector buffer(buffer_count); for (size_t i = 0; i *ptr) ? max_value : *ptr; ++ptr; max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; } switch (buffer_count % 8) { case 7: max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; [[fallthrough]]; case 6: max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; [[fallthrough]]; case 5: max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; [[fallthrough]]; case 4: max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; [[fallthrough]]; case 3: max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; [[fallthrough]]; case 2: max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; [[fallthrough]]; case 1: max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; } std::cout 对以上代码进行优化： #include #include int main() { constexpr size_t buffer_count = 10001; std::vector buffer(buffer_count); for (size_t i = 0; i *ptr) ? max_value : *ptr; ++ptr; [[fallthrough]]; case 7: max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; [[fallthrough]]; case 6: max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; [[fallthrough]]; case 5: max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; [[fallthrough]]; case 4: max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; [[fallthrough]]; case 3: max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; [[fallthrough]]; case 2: max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; [[fallthrough]]; case 1: max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; } for (size_t i = 0; i *ptr) ? max_value : *ptr; ++ptr; max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; } std::cout 最后，可以看出，switch结构和for循环结构重复代码较多，我们把代码去重后就得到了达夫设备。 #include #include int main() { constexpr size_t buffer_count = 10001; std::vector buffer(buffer_count); for (size_t i = 0; i *ptr) ? max_value : *ptr; ++ptr; [[fallthrough]]; case 7: max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; [[fallthrough]]; case 6: max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; [[fallthrough]]; case 5: max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; [[fallthrough]]; case 4: max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; [[fallthrough]]; case 3: max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; [[fallthrough]]; case 2: max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; [[fallthrough]]; case 1: max_value = (max_value > *ptr) ? max_value : *ptr; ++ptr; } std::cout Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-26 17:49:19 "},"chapter7/":{"url":"chapter7/","title":"函数","keywords":"","body":"函数基础 函数详解 函数重载与重载解析 函数相关的其他内容 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-29 13:37:14 "},"chapter7/1.html":{"url":"chapter7/1.html","title":"函数基础","keywords":"","body":"函数基础 函数：封装了一段代码，可以在一次执行过程中被反复调用。 函数头 函数名称 —— 标识符，用于后续的调用 形式参数 —— 代表函数的输入参数 返回类型 —— 函数执行完成后所返回的结果类型 函数体 为一个语句块（ block ），包含了具体的计算逻辑 函数声明与定义 函数声明只包含函数头，不包含函数体，通常置于头文件中 函数声明可出现多次，但函数定义通常只能出现一次（存在例外） 函数调用 需要提供函数名与实际参数 实际参数拷贝初始化形式参数 返回值会被拷贝给函数的调用者 栈帧结构 #include int Add(int x, int y); int Add(int x, int y) { return x + y; } int Sub(int x, int y) { return x - y; } int main(int argc, char **argv) { std::cout 拷贝过程的（强制）省略 返回值优化 C++17 强制省略拷贝临时对象 函数的外部链接 编译上述代码得到可执行文件 test，使用 nm test 命令查看函数的外部链接 nm是一个命令行工具，用来列出object文件、库文件或可执行文件中的符号列表(name list, the symbol table of nlist structures)。 nm命令的输出结果为三列，symbol virtual address，symbol type和symbol name，即符号虚拟地址，类型和名字。 0000000000201010 B __bss_start 0000000000201130 b completed.7698 U __cxa_atexit@@GLIBC_2.2.5 w __cxa_finalize@@GLIBC_2.2.5 0000000000201000 D __data_start 0000000000201000 W data_start 00000000000007b0 t deregister_tm_clones 0000000000000840 t __do_global_dtors_aux 0000000000200d88 t __do_global_dtors_aux_fini_array_entry 0000000000201008 D __dso_handle 0000000000200d90 d _DYNAMIC 0000000000201010 D _edata 0000000000201138 B _end 00000000000009d4 T _fini 0000000000000880 t frame_dummy 0000000000200d78 t __frame_dummy_init_array_entry 0000000000000bcc r __FRAME_END__ 0000000000200f90 d _GLOBAL_OFFSET_TABLE_ 0000000000000941 t _GLOBAL__sub_I__Z3Addii w __gmon_start__ 00000000000009e8 r __GNU_EH_FRAME_HDR 0000000000000708 T _init 0000000000200d88 t __init_array_end 0000000000200d78 t __init_array_start 00000000000009e0 R _IO_stdin_used w _ITM_deregisterTMCloneTable w _ITM_registerTMCloneTable 00000000000009d0 T __libc_csu_fini 0000000000000960 T __libc_csu_init U __libc_start_main@@GLIBC_2.2.5 00000000000008b0 T main 00000000000007f0 t register_tm_clones 0000000000000780 T _start 0000000000201010 D __TMC_END__ 000000000000088a T _Z3Addii 000000000000089e T _Z3Subii 00000000000008f8 t _Z41__static_initialization_and_destruction_0ii U _ZNSolsEi@@GLIBCXX_3.4 U _ZNSolsEPFRSoS_E@@GLIBCXX_3.4 U _ZNSt8ios_base4InitC1Ev@@GLIBCXX_3.4 U _ZNSt8ios_base4InitD1Ev@@GLIBCXX_3.4 0000000000201020 B _ZSt4cout@@GLIBCXX_3.4 U _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_@@GLIBCXX_3.4 00000000000009e4 r _ZStL19piecewise_construct 0000000000201131 b _ZStL8__ioinit 现在显示的为 mangling style 风格，现在使用 nm test | c++filt -t 进行 Demangling 0000000000201010 B __bss_start 0000000000201130 bool completed.7698 U __cxa_atexit@@GLIBC_2.2.5 wchar_t __cxa_finalize@@GLIBC_2.2.5 0000000000201000 D __data_start 0000000000201000 W data_start 00000000000007b0 unsigned short deregister_tm_clones 0000000000000840 unsigned short __do_global_dtors_aux 0000000000200d88 unsigned short __do_global_dtors_aux_fini_array_entry 0000000000201008 D __dso_handle 0000000000200d90 double _DYNAMIC 0000000000201010 D _edata 0000000000201138 B _end 00000000000009d4 T _fini 0000000000000880 unsigned short frame_dummy 0000000000200d78 unsigned short __frame_dummy_init_array_entry 0000000000000bcc r __FRAME_END__ 0000000000200f90 double _GLOBAL_OFFSET_TABLE_ 0000000000000941 unsigned short _GLOBAL__sub_I__Z3Addii wchar_t __gmon_start__ 00000000000009e8 r __GNU_EH_FRAME_HDR 0000000000000708 T _init 0000000000200d88 unsigned short __init_array_end 0000000000200d78 unsigned short __init_array_start 00000000000009e0 R _IO_stdin_used wchar_t _ITM_deregisterTMCloneTable wchar_t _ITM_registerTMCloneTable 00000000000009d0 T __libc_csu_fini 0000000000000960 T __libc_csu_init U __libc_start_main@@GLIBC_2.2.5 00000000000008b0 T main 00000000000007f0 unsigned short register_tm_clones 0000000000000780 T _start 0000000000201010 D __TMC_END__ 000000000000088a T Add(int, int) 000000000000089e T Sub(int, int) 00000000000008f8 unsigned short __static_initialization_and_destruction_0(int, int) U std::basic_ostream >::operator >::operator >& (*)(std::basic_ostream >&))@@GLIBCXX_3.4 U std::ios_base::Init::Init()@@GLIBCXX_3.4 U std::ios_base::Init::~Init()@@GLIBCXX_3.4 0000000000201020 B std::cout@@GLIBCXX_3.4 U std::basic_ostream >& std::endl >(std::basic_ostream >&)@@GLIBCXX_3.4 00000000000009e4 r std::piecewise_construct 0000000000201131 bool std::__ioinit [!TIP] 可以看到函数和函数的参数类型 000000000000088a T Add(int, int) 000000000000089e T Sub(int, int) 当使用 extern \"C\" 进行声明和定义的时候，函数就是 C 类型的了，函数无法重载 extern \"C\" int Add(int x, int y); 但是使用 nm test | c++filt -t 会在其中发现 000000000000088a T Add 这样 C++ 的外部链接就改成了 C 语言可以使用的形式 不能重载的问题说明：比如下面的程序 #include extern \"C\" int Add(int x, int y) { return x + y; } int Add(int x) { return x; } int main(int argc, char **argv) { std::cout 如果按照上面的方式进行重载则没有问题，在 Demangling 后可以看到两个不同的 Add 链接名称 000000000000088a T Add ... 000000000000088a T _Z3Addii 但是如何按照下面的方式会生成两个相同的 T Add 冲突，所以编译会出错 #include extern \"C\" int Add(int x, int y) { return x + y; } extern \"C\" int Add(int x) { return x; } int main(int argc, char **argv) { std::cout Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-29 15:36:30 "},"chapter7/2.html":{"url":"chapter7/2.html","title":"函数详解","keywords":"","body":"函数详解 参数 函数可以在函数头的小括号中包含零到多个形参 包含零个形参时，可以使用 void 标记（fun(void)） 对于非模板函数来说，其每个形参都有确定的类型，但形参可以没有名称（比如暂时不用的参数，只用一个类型占坑） 形参名称的变化并不会引入函数的不同版本 实参到形参的拷贝求值顺序不定， C++17 强制省略复制临时对象 #include void fun(void) { } void fun1(int, int y) { } 函数传值、传址、传引用 #include void fun(int par) { ++par; } void fun1(int* par) { ++(*par); } void fun2(int& par) { ++par; } int main() { int arg = 3; // 传值 fun(arg); // int par = arg; ++par; std::cout 函数传参过程中的类型退化 #include void fun(int* par) // (int par[]) (int *par) 也是可以的 { } void fun1(int (&par)[3]) { } int main() { int a[3]; fun(a); // 类型退化为指针 fun1(a); // 传入引用防止类型退化 } 变长参数 initializer_list（传递的参数类型相同，std::initializer_list是非常便宜的，它只包含了两个指针） #include #include void fun(std::initializer_list par) { std::cout 可变长度模板参数 使用省略号表示形式参数 函数可以定义缺省实参 如果某个形参具有缺省实参，那么它右侧的形参都必须具有缺省实参 #include void fun(int x = 0) { std::cout 在一个翻译单元中，每个形参的缺省实参只能定义一次（注意在一个翻译单元中） void fun(int x, int y, int z = 3); // 在多个翻译单元定义可实现分级 void fun(int x, int y = 1, int z); void fun(int x = 1, int y, int z); void fun(int x, int y, int z) { std::cout 具有缺省实参的函数调用时，传入的实参会按照从左到右的顺序匹配形参 缺省实参为对象时，实参的缺省值会随对象值的变化而变化 #include int x = 3; void fun(int y = x) // 不建议这么写！ { std::cout main 函数的两个版本 cppreference - main 无形参版本 带两个形参的版本 int main (int argc, char *argv[]) { 函数体 } argc - 非负数，表示从程序运行的环境传递给程序的实参个数。 argv - 指针，指向包含 argc + 1 个指针的数组的首元素。数组末元素是空指针，如果它前面有任何元素，那么它们指向空终止多字节字符串，表示从执行环境传递给程序的若干参数。如果 argv[0] 不是空指针，或等价地 argc > 0 ，那么它指向表示用于调用程序的名称的字符串，或空字符串。 int main(int argc, char* argv[]) { std::cout 在控制台运行 ./demo argc = 1 ./demo 运行 ./demo 1 2 3 argc = 4 ./demo 1 2 3 为什么 argv 的第一位是程序名称，以下，可以说明，如果传递的参数不符合要求则返回 Usage: ./demo param1 param2 int main(int argc, char* argv[]) { if (argc != 3) { std::cout 函数体 函数体形成域： 其中包含了自动对象（内部声明的对象以及形参对象） 也可包含局部静态对象 函数体执行完成时的返回 隐式返回（ main 返回的隐式返回，返回程序运行状态的标志，通常返回 0 表示程序运行正常，可以通过 echo $? 来获取程序运行后 main 函数的返回值） void fun() { std::cout 显式返回关键字： return return; 语句 return 表达式; return 初始化列表; 小心返回自动对象的引用或指针 返回值优化（ RVO ） —— C++17 对返回临时对象的强制优化 struct Str { Str() = default; Str(const Str&) { std::cout 返回类型 返回类型表示了函数计算结果的类型，可以为 void 返回类型的几种书写方式 经典方法：位于函数头的前部 C++11 引入的方式：位于函数头的后部（eg：简化函数定义） auto fun(int a, int b) -> int { return a + b; } // S::MyAdd S::fun(int a, int b) auto S::fun(int a, int b) -> MyAdd { } C++14 引入的方式：返回类型的自动推导 使用 constexpr if 构造 “ 具有不同返回类型 ” 的函数 auto fun(int a, int b) { return a + b; } // 编译期已经确定了返回类型 constexpr bool value = true; auto fun1() { if constexpr (value) { return 1; } else { return 3.14; } } 返回类型与结构化绑定（ C++ 17 ） #include struct Str { int x = 2; int y = 4; }; Str fun() { return Str{}; } int main() { auto [v1, v2] = fun(); // Str __fun16 = fun(); // int & v1 = __fun16.x; // int & v2 = __fun16.y; v1; v2; std::cout [[nodiscard]] 属性（ C++ 17 ），表明函数的返回值非常重要，给出一个警告，不要直接调用而不关心返回值。 #include [[nodiscard]] int fun(int a, int b) { return a + b; } int main() { fun(2, 3); // warning: ignoring return value of 'int fun(int, int)', declared with attribute nodiscard [-Wunused-result] fun(2, 3); // declared here [[nodiscard]] int fun(int a, int b) } Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-30 11:05:56 "},"chapter7/3.html":{"url":"chapter7/3.html","title":"函数重载与重载解析","keywords":"","body":"函数重载与重载解析 函数重载：使用相同的函数名定义多个函数,每个函数具有不同的参数列表 #include int fun(int x) { return x + 1; } int fun(int x, int y) { return x + y; } double fun(double x) { return x + 1; } int main() { std::cout 不能基于不同的返回类型进行重载 int fun(int x) { return x + 1; } double fun(int x) { return x + 1; } int main() { fun(3); // 这样调用程序无法选择哪一个 fun 函数 } 函数重载与 name mangling，对上述函数编译的可执行文件进行 nm 000000000000091d T _Z3fund 00000000000008fa T _Z3funi 0000000000000909 T _Z3funii 0000000000000a24 T _Z3funiii 进行 Demangling 000000000000091d T fun(double) 00000000000008fa T fun(int) 0000000000000909 T fun(int, int) 0000000000000a24 T fun(int, int, int) 编译器如何选择正确的版本完成函数调用 ?（重载解析：Template Argument Deduction） 参考资源： Calling_Functions： A Tutorial 名称查找 限定查找( qualified lookup )与非限定查找( unqualified lookup ) 非限定查找会进行域的逐级查找 —— 名称隐藏( hiding ) #include void fun() { std::cout 查找通常只会在已声明的名称集合中进行 下面的例子说明了这一点，编译是顺序执行的，当到 g() 函数时程序所能找到的 fun 函数只有第一个，如果在 g() 函数前加上第二个 fun 函数的声明或将它放到 g() 函数的前面则程序的运行结果会不同，显然第二个 fun 函数更符合。 #include void fun(int) { std::cout 实参依赖查找( Argument Dependent Lookup： ADL ) 只对自定义类型生效 #include namespace MyNS { struct Str {}; void g(Str x) { } } int main() { MyNS::Str obj; g(obj); } 重载解析（重载决议） 重载解析：在名称查找的基础上进一步选择合适的调用函数 过滤不能被调用的版本 (non-viable candidates) 参数个数不对 无法将实参转换为形参 实参不满足形参的限制条件 #include void fun(int x) { } void fun(std::string x) { } int main() { fun(3); } 在剩余版本中查找与调用表达式最匹配的版本,匹配级别越低越好(有特殊规则) 级别 1 ：完美匹配 或 平凡转换(比如加一个 const ) 级别 2 ： promotion 或 promotion 加平凡转换 级别 3 ：标准转换 或 标准转换加平凡转换 级别 4* ：自定义转换 或 自定义转换加平凡转换 或 自定义转换加标准转换 级别 5* ：形参为省略号的版本 void fun(...) 函数包含多个形参时,所选函数的所有形参的匹配级别都要优于或等于其它函数 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-30 11:17:03 "},"chapter7/4.html":{"url":"chapter7/4.html","title":"函数相关的其他内容","keywords":"","body":"函数相关的其他内容 递归函数:在函数体中调用其自身的函数 通常用于描述复杂的迭代过程 内联函数 / constexpr 函数 (C++11 起 ) / consteval 函数 (C++20 起 )：（都是翻译单元预处理的原则） 内联函数 #include // in line (内联) 不进行 -O3 优化函数执行会有栈帧的构造与销毁，影响性能 void fun() { std::cout 使用 inline 关键字可以打破翻译单元的一次定义原则限制，在程序级别判断 // header.h #include void fun(); inline void fun() { std::cout void fun2() { fun(); } // main.cpp #include #include \"header.h\" int main() { fun(); // Hello } constexpr 函数 (C++11 起 )，可以在编译器和运行期间执行 #include constexpr int fun(int x) { int y = 1; // std::cin >> y; constexpr 函数所有内容在编译期都必须可以执行 return x + 1; } constexpr int x = fun(); int main() { fun(3); // 编译器执行 int y = 0; std::cin >> y; fun(y) // 运行期执行 } consteval 函数 (C++20 起 ) consteval 函数只能在编译器执行 优化程序执行 避免函数的误执行 consteval int fun(int x) { return x + 1; } int main() { constexpr int x = fun(3); } 函数指针 函数类型与函数指针类型（函数指针在高阶函数中应用比较多：泛型算法），函数是不能复制的，复制时会转化为函数指针类型 #include int fun(int x) // int(int) { return x + 1; } using L = int(int); L funL; // 等于函数声明 int main() { L* funPtr = &fun; std::cout 函数指针与重载 #include void fun(int) { } void fun(int, int) { } int main() { // auto x = fun; // 将第二个 fun 注释掉则：using FuncPtr_14 = void (*)(int); // 但是上面如果将注释代码放开则会报错， auto 无法推断出变量类型，此时 fun 是一组函数，此时应该显式给出函数指针类型 using K = void(int); K* x = fun; } 将函数指针作为函数参数 #include #include #include int inc(int x) { return x + 1; } int main() { std::vector a = {1, 2, 3, 4}; std::transform(a.cbegin(), a.cend(), a.begin(), inc); for (int x : a) { std::cout 将函数指针作为函数返回值 #include int inc(int x) { return x + 1; } int dec(int x) { return x - 1; } auto fun(bool input) { if (input) { return inc; } else { return dec; } } int main() { std::cout 小心: Most vexing parse Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-30 11:38:36 "},"chapter8/":{"url":"chapter8/","title":"深入IO","keywords":"","body":"IOStream概述 输入与输出 文件与内存操作 流的状态、定位与同步 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-30 13:06:29 "},"chapter8/1.html":{"url":"chapter8/1.html","title":"IOStream概述","keywords":"","body":"IOStream概述 IOStream 采用流式 I/O 而非记录 I/O ，但可以在此基础上引入结构信息 所处理的两个主要问题 表示形式的变化：使用格式化 / 解析在数据的内部表示与字符序列间转换 #include int main() { union { int x; int y; // float y; }; x = 100; std::cout 与外部设备的通信：针对不同的外部设备（终端、文件、内存）引入不同的处理逻辑 所涉及到的操作 格式化 / 解析 缓存 编码转换 传输 采用模板来封装字符特性，采用继承来封装设备特性 常用的类型实际上是类模板实例化的结果 std::basic_ifstream ios_base 对于 fstream #include #include int main() { std::ifstream x; } 使用 c++ insight 进行源码探查可得 #include #include int main() { std::basic_ifstream x = std::basic_ifstream(); return 0; } Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-30 15:34:20 "},"chapter8/2.html":{"url":"chapter8/2.html","title":"输入与输出","keywords":"","body":"输入与输出 cppreference - 输入与输出 输入与输出分为格式化与非格式化两类 非格式化 I/O 非格式化 I/O ：不涉及数据表示形式的变化 常用输入函数： get / read / getline / gcount 常用输入函数： put / write 这里使用 std::basic_istream::read 来做个实验 #include int main() { int x; //std::cin >> x; // reinterpret_cast(&x) 将 int 型指针转化为 char 类型 // basic_istream& read( char_type* s, std::streamsize count ); std::cin.read(reinterpret_cast(&x), sizeof(x)); // 非格式化输入 std::cout 当输入 100 时候，打印的是 100 和回车对应的编码，而不是向 cin 输入时打印的 100 当我们输入 1 并回车时候，因为 int 在本地占四个字节，而 1 和回车只占用了两个字节，所以程序会继续等待用户输入 格式化 I/O 格式化 I/O ：使用移位操作符来进行的输入 (>>) 与输出 () C++ 通过操作符重载以支持内建数据类型的格式化 I/O 可以通过重载操作符以支持自定义类型的格式化 I/O #include int main() { char x = '0'; std::cout (x); std::cout 格式控制 可接收位掩码类型（ showpos ）、字符类型（ fill ）与取值相对随意（ width ）的格式化参数 注意 width 方法的特殊性：触发后被重置 #include int main() { char x = '0'; std::cout.setf(std::ios_base::showpos); std::cout.width(10); // 触发后被重置 std::cout.fill('.'); std::cout (x); std::cout.width(10); std::cout 操纵符 简化格式化参数的设置 触发实际的插入与提取操作 以下使用操纵符输出结果与上例相同 #include #include int main() { char x = '0'; int y = static_cast(x); std::cout 提取会放松对格式的限制 可以自行测试 int char 等类型 #include int main() { int x; std::cin >> x; // +010 std::cout 提取 C 风格字符串时要小心内存越界 #include #include int main() { std::string x; // char a[6]; 内存越界 std::cin >> x; // qwertyui std::cout 可以使用下面方式（格式控制）防止内存越界 #include #include #include int main() { char x[3]; std::cin >> std::setw(3) >> x; // qwer std::cout Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-30 16:28:31 "},"chapter8/3.html":{"url":"chapter8/3.html","title":"文件与内存操作","keywords":"","body":"文件与内存操作 文件操作 basic_ifstream / basic_ofstream / basic_fstream 文件流可以处于打开 / 关闭两种状态，处于打开状态时无法再次打开，只有打开时才能 I/O #include #include #include int main() { std::ofstream outFile(\"my_file\"); if (outFile.is_open()) { outFile > x; std::cout [!TIP] 一般不使用 open 和 close ，而是直接构造 std::ofstream outFile(\"my_file\"); 对象时候就与文件进行关联，随着对象的销毁会自动关闭文件 文件流的打开模式（下表引自 C++ IOStream 一书） 每种文件流都有缺省的打开方式 注意 ate 与 app 的异同 binary 能禁止系统特定的转换 \\0 \\n 避免意义不明确的流使用方式（如 ifstream + out ） #include #include #include int main() { //void open( const char *filename, ios_base::openmode mode = ios_base::out ); std::ofstream outFile(\"my_file\", std::ios_base::out | std::ios_base::app); // 每次都从文件末尾开始写入 outFile 标记名 作用 in 打开以供读取 out 打开以供写入 ate 表示起始位置位于文件末尾 app 附加文件，即总是向文件尾写入 trunc 截断文件，即删除文件中的内容 binary 二进制模式 合法的打开方式组合（引自 C++ IOStream 一书）可以查看 cppreference - basic_ofstream - open 或 basic_ifstream - open 内存流 内存流： basic_istringstream basic_ostringstream basic_stringstream #include #include #include int main() { std::ostringstream obj1; obj1 #include #include #include int main() { std::ostringstream obj1; obj1 > x; std::cout 也会受打开模式： in / out / ate / app 的影响 #include #include #include int main() { std::ostringstream obj1(\"test\", std::ios_base::ate); obj1 使用 str() 方法获取底层所对应的字符串 小心避免使用 str().c_str() 的形式获取 C 风格字符串 #include #include #include int main() { std::ostringstream obj(\"test\", std::ios_base::app); obj 基于字符串流的字符串拼接优化操作（涉及到内存的拷贝、开辟与释放，字符串流更加节约资源，减少了内存的拷贝、开辟与释放。） #include #include #include int main() { std::string x; x += \"hello\"; x += \"hello\"; x += \"hello\"; // ... std::cout Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2022-12-31 00:28:14 "},"chapter8/4.html":{"url":"chapter8/4.html","title":"流的状态、定位与同步","keywords":"","body":"流的状态、定位与同步 流的状态 iostate failbit / badbit / eofbit / goodbit // badbit eg：未关联文件就写入 std::ofstream outfile; outfile > x; // 输入 hello // failbit eg：本身就是关闭的文件又进行了关闭 std::ofstream outfile; outfile.close(); // eofbit // Linux 系统终端输入 Ctrl + D （在终端输入达到终端输入的结尾） int x; std::cin >> x; 检测流的状态 good() / fail() / bad() / eof() 方法 转换为 bool 值（参考cppreference） #include #include #include int main() { int x; std::cin >> x; std::cout (std::cin) 10001 // ctrl + D -> 01010 // hello -> 01000 } 注意区分 fail 与 eof 可能会被同时设置，但二者含意不同 转换为 bool 值时不会考虑 eof 通常来说，只要流处于某种错误状态时，插入 / 提取操作就不会生效 复位流状态 clear ：设置流的状态为具体的值（缺省为 goodbit ） `setstate`` ：将某个状态附加到现有的流状态上 捕获流异常：exceptions方法 流的定位 获取流位置 tellp() / tellg() 可以用于获取输入 / 输出流位置 (pos_type 类型 ) 两个方法可能会失败，此时返回 pos_type(-1) 设置流位置 seekg() / seekp() 用于设置输入 / 输出流的位置 这两个方法分别有两个重载版本： 设置绝对位置：传入 pos_type 进行设置 设置相对位置：通过偏移量（字符个数 ios_base::beg ） + 流位置符号的方式设置 ios_base::beg ios_base::cur ios_base::end #include #include #include int main() { std::string str = \"Hello, world\"; std::istringstream in(str); std::string word1, word2; in >> word1; in.seekg(0); // 回溯 in >> word2; std::cout 流的同步 基于 flush() / sync() / unitbuf 的同步 flush() 用于输出流同步，刷新缓冲区 sync() 用于输入流同步，其实现逻辑是编译器所定义的 输出流可以通过设置 unitbuf 来保证每次输出后自动同步 基于绑定 (tie) 的同步 流可以绑定到一个输出流上，这样在每次输入 / 输出前可以刷新输出流的缓冲区 比如： cin 绑定到了 cout 上 与 C 语言标准 IO 库的同步 缺省情况下， C++ 的输入输出操作会与 C 的输入输出函数同步 可以通过 sync_with_stdio 关闭该同步 #include #include int main() { std::ios::sync_with_stdio(true); std::cout Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-01 00:49:18 "},"chapter9/":{"url":"chapter9/","title":"动态内存管理","keywords":"","body":"动态内存管理基础 智能指针 动态内存的相关问题 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-01 14:41:56 "},"chapter9/1.html":{"url":"chapter9/1.html","title":"动态内存管理基础","keywords":"","body":"动态内存管理基础 栈内存 堆内存 V.S. 栈内存的特点：更好的局部性，对象自动销毁 堆内存的特点：运行期动态扩展，需要显式释放 在 C++ 中通常使用 new 与 delete 来构造、销毁对象 #include int* fun() { int *res = new int(2); return res; } int main() { int* y = fun(); std::cout 对象的构造分成两步：分配内存与在所分配的内存上构造对象；对象的销毁与之类似 new 的几种常见形式 构造单一对象 / 对象数组 int* x = new int[3]{1, 3, 54}; std::cout nothrow new #include #include int main() { int* x = new (std::nothrow) int[3]{1, 3, 54}; if (y == nullptr) { // ... 分配不成功逻辑 } std::cout placement new #include #include int main() { char ch[sizeof(int)]; int* x = new (ch) int(4); // 提供了一块 ch 内存 std::cout new auto int* x = new int(3); int* y = new auto(3); new 与对象对齐 #include #include struct alignas(256) Str{}; // 字节对齐 256 int main() { Str* ptr = new Str(); // 开辟的内存首地址是 256 的整数倍 std::cout delete 的常见用法 销毁单一对象 / 对象数组 placement delete：销毁对象但是不把对象对应的内存归还给系统 #include #include int main() { int* x = new int(3); delete x; int* ptr = new int[5]; delete[] ptr; } 使用 new 与 delete 的注意事项 根据分配的是单一对象还是数组，采用相应的方式销毁 delete nullptr 不能delete 一个非 new 返回的内存 int x; delete &x; // 不允许 同一块内存不能 delete 多次 #include #include int main() { int* x = new int(3); std::cout 调整系统自身的 new/ delete 行为 不要轻易使用 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-01 15:38:25 "},"chapter9/2.html":{"url":"chapter9/2.html","title":"智能指针","keywords":"","body":"智能指针 使用 new 与 delete 的问题：内存所有权不清晰，容易产生不销毁，多销毁的情况 C++ 的解决方案：智能指针（抽象数据类型） auto_ptr （ C++17 删除） shared_ptr / uniuqe_ptr / weak_ptr shared_ptr —— 基于引用计数的共享内存解决方案 基本用法 #include #include int main() { // int* x(new int(3)); std::shared_ptr x(new int(3)); } reset / get 方法 #include #include std::shared_ptr fun() { std::shared_ptr res(new int(3)); return res; } void fun2(int* x) { std::cout x = fun(); std::cout ' to 'int*' for argument '1' to 'void fun2(int*)' x.reset(new int(4)); fun2(x.get()); // 4 // x.reset(nullptr); // error: no matching function for call to 'std::shared_ptr::reset(std::nullptr_t)' x.reset((int*)nullptr); // 等价于 x.reset(); } 指定内存回收逻辑 #include #include void fun(int* ptr) { std::cout fun() { static int res = 3; return std::shared_ptr(&res, dummy); } int main() { std::shared_ptr a(new int(3), fun); // Call deleter fun std::shared_ptr x = fun(); } std::make_shared #include #include int main() { // std::shared_ptr x = new int(3); auto x = std::make_shared(3); // = std::shared_ptr x = std::make_shared(3); } 支持数组（ C++17 支持 shared_ptr ； C++20 支持 make_shared 分配数组） 注意： shared_ptr 管理的对象不要调用 delete 销毁 #include #include int main() { // std::shared_ptr x(new int[5]); // shared_ptr 释放内存实际是 delete (x.get()) 这样程序行为是未定义的 // c++ 17 std::shared_ptr x(new int[5]); // c++ 20 auto x = std::make_shared(); // = auto x = std::make_shared(5); } unique_ptr —— 独占内存的解决方案 基本用法 unique_ptr 不支持复制，但可以移动 #include #include int main() { std::unique_ptr x(new int(3)); // std::unique_ptr y = x; std::cout y = std::move(x); std::cout 为 unique_ptr 指定内存回收逻辑 #include #include void fun(int* ptr) { std::cout x(new int(3), fun); // Fun is called } weak_ptr —— 防止循环引用而引入的智能指针 基于 shared_ptr 构造 下面的程序就会形成循环引入 #include #include struct Str { std::shared_ptr nei; ~Str() { std::cout x(new Str); std::shared_ptr y(new Str); x->nei = y; y->nei = x; } 修改上面的代码 -> 防止循环引入 struct Str { std::weak_ptr nei; ~Str() { std::cout lock 方法 #include #include struct Str { std::weak_ptr nei; ~Str() { std::cout x(new Str); { std::shared_ptr y(new Str); x->nei = y; } if (auto ptr = x->nei.lock(); ptr) { std::cout Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-01 20:33:17 "},"chapter9/3.html":{"url":"chapter9/3.html","title":"动态内存的相关问题","keywords":"","body":"动态内存的相关问题 sizeof 不会返回动态分配的内存大小 #include #include #include int main() { int* ptr = new int(3); std::cout x; std::cout ) 使用分配器（ allocator ）来分配内存，对应对象构造第一步，分配内存 #include #include int main() { std::allocator al; int* ptr = al.allocate(3); al.deallocate(ptr, 3); } 使用 malloc / free 来管理内存（无法分配对齐内存） #include #include #include int main() { // 为 4 个 string 的数组分配足够空间 if(auto p = (std::string*)std::malloc(4 * sizeof(std::string))) { int i = 0; try { for(; i != 4; ++i) // 填充数组 new(p + i) std::string(5, 'a' + i); for(int j = 0; j != 4; ++j) // 打印出来 std::cout 使用 aligned_alloc 来分配对齐内存 动态内存与异常安全 C++ 对于 垃圾回收 的支持 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-01 21:22:00 "},"chaptera/":{"url":"chaptera/","title":"序列与关联容器","keywords":"","body":"容器概述 序列容器 关联容器 适配器与生成器 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-01 21:29:45 "},"chaptera/1.html":{"url":"chaptera/1.html","title":"容器概述","keywords":"","body":"容器概述 容器 cppreference - 容器库 容器：一种特殊的类型，其对象可以放置其它类型的对象（元素） 需要支持的操作：对象的添加、删除、索引、遍历 有多种算法可以实现容器，每种方法各有利弊 容器分类 序列容器：其中的对象有序排列，使用整数值进行索引 关联容器：其中的对象顺序并不重要，使用键进行索引 适配器：调整原有容器的行为，使得其对外展现出新的类型、接口或返回新的元素 生成器：构造元素序列 迭代器 迭代器：用于指定容器中的一段区间，以执行遍历、删除等操作 获取迭代器： (c)begin/(c)end ； (c)rbegin/(c)rend 迭代器分类：分成 5 类（ category ），不同的类别支持的操作集合不同 #include #include int main() { std::vector x{1, 2, 3}; auto b = x.begin(); auto e = x.end(); for (auto ptr = b; ptr Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-02 14:46:34 "},"chaptera/2.html":{"url":"chaptera/2.html","title":"序列容器","keywords":"","body":"序列容器 C++ 标准库中提供了多种序列容器模板 array ：元素个数固定的序列容器 vector ：元素连续存储的序列容器 forward_list / list ：基于链表 / 双向链表的容器 deque ： vector 与 list 的折中 basic_string ：提供了对字符串专门的支持 需要使用元素类型来实例化容器模板，从而构造可以保存具体类型的容器。 不同的容器所提供的接口大致相同，但根据容器性质的差异，其内部实现与复杂度不同。 对于复杂度过高的操作，提供相对较难使用的接口或者不提供相应的接口 array 容器模板 array 容器模板：具有固定长度的容器，其内部维护了一个内建数组，与内建数组相比提供了复制操作 提供的接口 构造 成员类型： value_type 等 元素访问： [] ， at， front ， back ， data 容量相关（平凡实现）：empty ， size ， max_size 填充与交换： fill ， swap 比较操作： 迭代器 #include #include #include int main() { std::array a{1, 2, 3}; std::cout ::value_type, int>::value b{4, 5, 6}; // 成本很高 a.swap(b); // a: 4 5 6 b: 10 10 10 } vector 容器模板 vector 容器模板：元素可变（图片来源： www.sthu.org ） 提供的接口 与 array 很类似，但有其特殊性 #include #include int main() { std::vector a{2}; std::cout b{1, 1, 3}; std::vector c{1}; std::cout b) c) 容量相关接口： capacity / reserve / shrink_to_fit #include #include int main() { std::vector a; a.reserve(1024); // 增加 vector 的容量到大于或等于 new_cap 的值 for (int i = 0; i 附加元素接口： push_back / emplace_back 元素插入接口： insert / emplace 元素删除接口： pop_back / erase / clear #include #include #include void print_vector_int(const std::vector& v) { for (int i : v) std::cout a; a.push_back(\"hello\"); a.emplace_back(\"world\"); // emplace_back 避免用 push_back 时的额外复制或移动操作 std::vector b(3, 100); auto x = b.begin(); b.insert(x, 200); print_vector_int(b); // 200 100 100 100 std::vector c{1, 2, 3, 4 ,5}; c.erase(c.begin() + 1, c.begin() + 2); print_vector_int(c); // 1 3 4 5 c.pop_back(); print_vector_int(c); // 1 3 4 c.clear(); print_vector_int(c); // 已清空 } 注意 vector 不提供 push_front / pop_front ，可以使用 insert / erase模拟，但效率不高 在 vector 的头部添加或删除元素是非常消耗性能的！ swap 效率较高（这里是指针地址的交换，不是实际的元素交换，所以效率高） #include #include #include int main() { std::vector a{1, 2, 3}; std::vector b{4, 5, 6}; auto ptr = a.begin(); std::cout 写操作可能会导致迭代器失效 list 容器模板 list 容器模板：双向链表（图片来源： blog.daum.net ） 与 vector 相比， list 插入、删除成本较低，但随机访问成本较高 提供了 pop_front / splice 等接口 写操作通常不会改变迭代器的有效性 #include #include #include void printlist(const std::list& l) { for (auto ptr = l.begin(); ptr != l.end(); ++ptr) { std::cout a{1, 2, 3}; printlist(a); a.push_front(20); // 在开头插入 a.push_back(10); // 在结尾添加 printlist(a); // 20 1 2 3 10 std::list b{4, 5, 6}; auto it = a.begin(); a.splice(it, b); printlist(a); // 4 5 6 20 1 2 3 10 a.sort(); printlist(a); // 1 2 3 4 5 6 10 20 a.reverse(); printlist(a); // 20 10 6 5 4 3 2 1 std::list c{1, 2, 2, 3, 3, 4, 6}; c.unique(); printlist(c); // 1 2 3 4 6 } forward_list 容器模板 forward_list 容器模板：单向链表（图片来源： www.usna.edu ） 目标：一个成本较低的线性表实现 其迭代器只支持递增操作，因此无 rbegin/rend 不支持 size 不支持 pop_back / push_back XXX_after 操作 #include #include #include #include void printforwardlist(const std::forward_list& l) { for (auto ptr = l.begin(); ptr != l.end(); ++ptr) { std::cout a{1, 2, 3, 4}; a.insert_after(a.begin(), 100); printforwardlist(a); // 1 100 2 3 4 a.insert_after(a.begin(), 2 ,100); printforwardlist(a); // 1 100 100 100 2 3 4 a.pop_front(); printforwardlist(a); // 100 100 100 2 3 4 a.push_front(2); printforwardlist(a); // 2 100 100 100 2 3 4 a.clear(); } deque容器模板 https://zh.cppreference.com/w/cpp/container/deque deque 容器模板： vector 与 list 的折衷 push_back / push_front 速度较快 在序列中间插入、删除速度较慢 #include #include int main() { // 创建容纳整数的 deque std::deque d = {7, 5, 16, 8}; // 从 deque 的首尾添加整数 d.push_front(13); d.push_back(25); // 迭代并打印 deque 的值 for(int n : d) std::cout basic_string 容器模板 basic_string 容器模板：实现了字符串相关的接口 使用 char 实例化出 std::string 提供了如 find ， substr 等字符串特有的接口 提供了数值与字符串转换的接口 针对短字符串的优化（ ） #include #include int main() { double f = 23.4; std::cout Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-04 23:02:06 "},"chaptera/3.html":{"url":"chaptera/3.html","title":"关联容器","keywords":"","body":"关联容器 使用键进行索引 set / map / multiset / multimap unordered_set / unordered_map / unordered_multiset / unordered_multimap set / map / multiset / multimap 底层使用红黑树实现 unordered_xxx 底层使用 hash 表实现（这个怪异的名字是因为 hash 的相关名称被其他厂商早已使用，所以只能起这样的名字） set （图片选自 www.cs.auckland.ac.nz ） 通常来说，元素需要支持使用 比较大小 或者采用自定义的比较函数来引入大小关系 #include #include struct Str { int x; }; bool MyComp(const Str& val1, const Str& val2) { return val1.x > s{10, 3, 2, 34}; // = std::set s{10, 3, 2, 34}; for (auto ptr = s.begin(); ptr!= s.end(); ++ptr) { std::cout > s1{10, 3, 2, 34}; for (auto ptr = s1.begin(); ptr!= s1.end(); ++ptr) { std::cout str({Str{3}, Str{5}}, MyComp); } 插入元素： insert / emplace / emplace_hint 删除元素： erase 访问元素： find / contains（-std=c++20） 修改元素： extract [!TIP] 注意： set 迭代器所指向的对象是 const 的，不能通过其修改元素 #include #include struct Str { int x; }; bool MyComp(const Str& val1, const Str& val2) { return val1.x s({Str{3}, Str{5}}, MyComp); s.emplace(Str{100}); s.insert(Str{30}); s.erase(Str{30}); s.erase(s.begin()); std::set Is{1, 3, 5, 6}; auto ptr = Is.find(1); if (ptr != Is.end()) std::cout map （图片选自 mropengate.blogspot.com ） 树中的每个结点是一个 std::pair #include #include int main() { std::map m{{3, true}, {4, false}, {6, true}}; for (auto ptr = m.begin(); ptr != m.end(); ++ptr) { auto p = *ptr; // std::pair std::cout 键 (pair.first) 需要支持使用 比较大小 或者采用自定义的比较函数来引入大小关系（参考 set） #include #include struct Str{}; int main() { std::map m{{1, Str{}}, {3, Str{}}, {5, Str{}}}; // error: no match for 'operator m{{Str{}, 4}, {Str{}, 6}, {Str{}, 8}}; } 访问元素： find / contains / [] / at #include #include int main() { std::map m; m.insert(std::pair(3, true)); m.insert({5, false}); m.erase(3); std::cout first second example = {{1,'a'},{2,'b'}}; for(int x: {2, 5}) { if(example.contains(x)) { std::cout [!TIP] map 迭代器所指向的对象是 std::pair ，其键是 const 类型 [] 操作不能用于常量对象 #include #include void fun(const std::map& m) { // 编译器运行，但是其中没有找到键 3 // m[3]; // error: passing 'const std::map' as 'this' argument discards qualifiers [-fpermissive] // 可以这样写 auto ptr = m.find(3); if (ptr != m.end()) { std::cout second m; m.insert(std::pair(3, 100)); fun(m); } multiset / multimap 与 set / map 类似，但允许重复键 元素访问 find 返回首个查找到的元素 count 返回元素个数 lower_bound / upper_bound / equal_range 返回查找到的区间 #include #include int main() { std::set s{1, 3, 5, 1}; for (auto i : s) std::cout s1{1, 3, 5, 1}; for (auto j : s1) std::cout unordered_set / unordered_map / unordered_multiset / unordered_multimap 图片选自 http://www.cxyzjd.com/article/I_ren/107671207 与 set / map 相比查找性能更好 但插入操作一些情况下会慢 其键需要支持两个操作 转换为 hash 值 判等 除 == ， != 外，不支持容器级的关系运算 但 ==， != 速度较慢 自定义 hash 与判等函数 #include #include struct Str { int x; }; size_t MyHash(const Str& val) { return val.x; } bool MyEqual(const Str& val1, const Str& val2) { return val1.x == val2.x; } class MyHashFunction { public: size_t operator()(const Str& t) const { return t.x; } }; int main() { // 在内部，元素并不以任何特别顺序排序，而是组织进桶中。元素被放进哪个桶完全依赖其值的哈希。 // 这允许对单独元素的快速访问，因为哈希一旦确定，就准确指代元素被放入的桶。 std::unordered_set s{3, 1, 4, 6, 1}; for (auto p : s) { std::cout e{1, MyHash, MyEqual}; e.insert(Str{3}); // decltype(&MyHash) -> size_t (*)(const Str& val) std::unordered_set us; } Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-05 21:08:44 "},"chaptera/4.html":{"url":"chaptera/4.html","title":"适配器与生成器","keywords":"","body":"适配器与生成器 类型适配器 basic_string_view（ C++17 ） 可以基于 std::string ， C 字符串，迭代器构造 提供成本较低的操作接口 不可进行写操作 #include #include #include void fun(std::string_view str) // 同时兼容 c c++ 字符串 { std::cout span （ C++20 ） 可基于 C 数组、 array 等构造 可读写 #include #include #include #include void fun(std::span input) { for (auto p : input) std::cout s{1, 2, 4, 5}; fun(s); } 接口适配器 stack / queue / priority_queue 对底层序列容器进行封装，对外展现栈、队列与优先级队列的接口 priority_queue 在使用时其内部包含的元素需要支持比较操作 #include #include #include int main() { std::stack> p; p.push(10); p.push(101); p.pop(); std::cout 数值适配器 (c++20) 数值适配器 (c++20) ： std::ranges::XXX_view，std::ranges::views::XXX， std::views::XXX 可以将一个输入区间中的值变换后输出 数值适配器可以组合，引入复杂的数值适配逻辑 #include #include #include bool isEven(int i) { return i % 2 == 0; } int Square(int i) { return i * i; } int main() { std::vector v{1, 2, 3, 4, 5}; for (auto p : std::ranges::filter_view(v, isEven)) { std::cout 生成器 (c++20) std::ranges::itoa_view，std::ranges::views::itoa， std::views::itoa 可以在运行期生成无限长或有限长的数值序列 #include #include int main() { for (int i : std::ranges::iota_view{1, 10}) std::cout Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-05 23:46:34 "},"chapterb/":{"url":"chapterb/","title":"泛型算法与 Lambda 表达式","keywords":"","body":"泛型算法 bind 与 lambda 表达式 泛型算法的改进——ranges Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-01 23:19:41 "},"chapterb/1.html":{"url":"chapterb/1.html","title":"泛型算法","keywords":"","body":"泛型算法 泛型算法：可以支持多种类型的算法 这里重点讨论 C++ 标准库中定义的算法 algorithm numeric ranges 为什么要引入泛型算法而不采用方法的形式 内建数据类型不支持方法 计算逻辑存在相似性，避免重复定义 如何实现支持多种类型：使用迭代器作为算法与数据的桥梁 泛型算法通常来说都不复杂，但优化足够好 一些泛型算法与方法同名，实现功能类似，此时建议调用方法而非算法 std::find V.S. std::map::find 泛型算法的分类 读算法：给定迭代区间，读取其中的元素并进行计算 accumulate / find / count 写算法：向一个迭代区间中写入元素 单纯写操作： fill / fill_n 读 + 写操作： transform / copy 注意：写算法一定要保证目标区间足够大 排序算法：改变输入序列中元素的顺序 sort / unique #include #include #include #include #include int main() { // 含有数个重复元素的 vector std::vector v{1, 2, 1, 1, 3, 3, 3, 4, 5, 4}; auto print = [&] (int id) { std::cout 泛型算法使用迭代器实现元素访问 迭代器的分类 cpp-reference-iterator 输入迭代器：可读，可递增 典型应用为 —— find 算法 输出迭代器：可写，可递增 典型应用为 —— copy 算法 前向迭代器：可读写，可递增 典型应用为 —— replace 算法 双向迭代器：可读写，可递增递减 典型应用为 —— reverse 算法 随机访问迭代器：可读写，可增减一个整数 典型应用为 —— sort 算法 一些算法会根据迭代器类别的不同引入相应的优化：如 distance 算法 一些特殊的迭代器 插入迭代器： back_insert_iterator / front_insert_iterator / insert_iterator #include #include #include int main() { std::vector x; std::fill_n(std::back_insert_iterator>(x), 10, 3); for (auto i : x) std::cout y; std::fill_n(std::back_inserter(y), 10, 3); for (auto j : y) std::cout 流迭代器： istream_iterator / ostream_iterator #include #include #include #include int main() { std::istringstream str(\"1 2 3 4 5\"); std::istream_iterator x(str); std::istream_iterator y{}; for (; x != y; ++x) std::cout #include #include #include #include #include int main() { std::istringstream str(\"1 2 3 4 5\"); std::istream_iterator x(str); std::istream_iterator y{}; int res = std::accumulate(x, y, 0); std::cout 反向迭代器（图片选自 www.cs.helsinki.fi ） 移动迭代器： move_iterator 迭代器与哨兵（ Sentinel ） 并发算法（SIMD C++17 / C++20 ） cppreference-execution_policy_tag std::execution::seq std::execution::par std::execution::par_unseq std::execution::unseq Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-08 21:46:52 "},"chapterb/2.html":{"url":"chapterb/2.html","title":"bind 与 lambda 表达式","keywords":"","body":"bind 与 lambda 表达式 很多算法允许通过可调用对象自定义计算逻辑的细节 transform / copy_if / sort… #include #include #include bool MyPredict(int val) { return val > 3; } int main() { std::vector x{1, 3, 5, 6, 7}; std::vector y; std::copy_if(x.begin(), x.end(), std::back_inserter(y), MyPredict); for (auto p : y) std::cout 如何定义可调用对象 函数指针：概念直观，但定义位置受限 类：功能强大，但书写麻烦 bind ：基于已有的逻辑灵活适配，但描述复杂逻辑时语法可能会比较复杂难懂 lambda 表达式：小巧灵活，功能强大 bind 早期的 bind 雏形： std::bind1st / std::bind2nd 具有了 bind 的基本思想，但功能有限 #include #include #include #include bool MyPredict(int val) { return val > 3; } int main() { std::vector x{4, 3, 5, 1, 7, 9, 6}; std::vector y; std::copy_if(x.begin(), x.end(), std::back_inserter(y), std::bind2nd(std::greater(), 3) ); for (auto p : y) std::cout #include #include #include #include bool MyPredict(int val) { return val > 3; } bool MyPredict2(int val1, int val2) { return val1 > val2; } int main() { using namespace std::placeholders; std::vector x{4, 3, 5, 1, 7, 9, 6}; std::vector y; std::copy_if(x.begin(), x.end(), std::back_inserter(y), std::bind(MyPredict2, _1, 3)); for (auto p : y) std::cout [!TIP] std::placeholders::_1 ：表示传入的第一个参数 bool MyPredict2(int val1, int val2) { return val1 > val2; } bool MyAnd(int val1, int val2) { return val1 && val2; } int main() { auto x1 = std::bind(MyPredict2, std::placeholders::_1, 4); auto x2 = std::bind(MyPredict2, 10, std::placeholders::_1); auto x3 = std::bind(MyAnd, x1, x2); std::cout std::bind （ C++11 引入）：用于修改可调用对象的调用方式 调用 std::bind 时，传入的参数会被复制，这可能会产生一些调用风险 void fun(int& x) { ++x; } int main() { int x = 0; fun(x); std::cout 可以使用 std::ref 或 std::cref 避免复制的行为 void fun(int& x) { ++x; } int main() { int y = 0; auto b = std::bind(fun, std::ref(y)); b(); std::cout std::bind_front （ C++20 引入）： std::bind 的简化形式 相当于简化了参数的传入 bool MyPredict(int val1, int val2) { return val1 > val2; } int main() { auto x = std::bind_front(MyPredict, 3); // 3 > 4 ? std::cout lambda 表达式 lambda 表达式（ https://leanpub.com/cpplambda ） 为了更灵活地实现可调用对象而引入 C++11 ~ C++20 持续更新 C++11 引入 lambda 表达式 C++14 支持初始化捕获、泛型 lambda C++17 引入 constexpr lambda ， *this 捕获 C++20 引入 concepts ，模板 lambda #include int main() { auto x = [](int val) { return val > 3 && val lambda 表达式会被编译器翻译成类进行处理 使用 c++ insights 源码探查工具查看可发现 lambda 表达式被翻译成了类 #include int main() { class __lambda_5_14 { public: inline /*constexpr */ bool operator()(int val) const { return (val > 3) && (val lambda 表达式的基本组成部分 参数与函数体 auto x = [](int val) { return val > 3 && val 返回类型（可让表达式自动推导，也可显式指定） 请看以下例子 #include int main() { auto x = [](int val) { if (val > 3) { return 3.0; } else return 1.5f; }; std::cout 当我们按照上面的书写时候表达式的返回类型无法被自动推导，则会报错，此时我们需要显式指定 auto x = [](int val) -> float { if (val > 3) { return 3.0; } else return 1.5f; }; 捕获：针对函数体中使用的局部自动对象进行捕获 值捕获、引用捕获与混合捕获 this 捕获 初始化捕获（ C++14 ） *this 捕获（ C++17 ） 我们看下面的例子 #include int main() { int y = 10; auto x = [](int val) { return val > y; }; std::cout 编译不通过，报错 error: 'y' is not captured 值捕获 ：此时需要将 lambda 表达式进行修改 int y = 10; auto x = [y](int val) { return val > y; }; 我们在看上面的例子，当我们想在 lambda 表达式中修改 y 的值时候需要这样做 #include int main() { int y = 10; auto x = [y] (int val) mutable { ++y; std::cout y; }; std::cout [!TIP] mutable 后面会介绍，不使用这个关键字则不能在表达式中修改 y 值捕获：其中可以看出表达式中的 y 只是程序中 y 的复制，修改表达式中的 y 不会对程序中的值产生影响，可以使用 C++ insights 查看 典型的值捕获：如果捕获列表中有很多元素，且都是值捕获，可以使用等于号 （auto x = [=] (int val) ）隐式书写，编译器会自动捕获 #include int main() { int y = 10; int z = 3; auto x = [=] (int val) { return val > z && val 引用捕获 ： 同上面，可以隐式捕获 auto x = [&] (int val) #include int main() { int y = 10; auto x = [&y] (int val) { ++y; std::cout y; }; std::cout 混合捕获：混合使用值捕获和引用捕获 #include int main() { int y = 10; int z = 3; auto x = [&y, z] (int val) { ++y; return val > z; }; std::cout 上面两种方式都有隐式方法，所以混合方式也有 #include int main() { int y = 10; int z = 3; auto x = [&, z] (int val) { ++y; return val > z && val auto x = [=, &z] (int val) 就不举例了 this 捕获 #include struct Str { auto fun() { int val = 3; auto lam = [val, this] () { return val > x; }; return lam(); } int x; }; int main() { Str s; s.fun(); } 初始化捕获（ C++14 ） #include #include int main() { std::string a = \"hello\"; auto lam = [y = std::move(a)] () { std::cout z; }; } *this捕获：确保安全（不会有悬挂指针，但是 *this 相当于复制了 Str ， 消耗了更多的资源） #include struct Str { auto fun() { int val = 3; auto lam = [val, *this] () { return val > x; }; return lam; } int x; }; auto wrapper() { Str s; return s.fun(); } int main() { auto lam = wrapper(); lam(); } 说明符 mutable / constexpr (C++17) / consteval (C++20)…… #include int main() { int y = 3; auto lam = [y] (int val) mutable // 不加则会报错，不允许修改 { ++y; return val > y; }; auto lam1 = [] (int val) constexpr // 可在编译期执行 { return val + 1; }; constexpr int val = lam1(100); } 模板形参（ C++20 ） #include int main() { auto lam = [](T val) constexpr { return val + 1; }; std::cout lambda 表达式的深入应用 捕获时计算（ C++14 ） int b = 10; int d = 30; auto lam = [z = b + d] (int val) { return val > z; }; 即调用函数表达式（ Immediately-Invoked Function Expression, IIFE ） 构建即执行 #include int main() { int b = 10; int d = 30; const auto lam = [z = b + d] () { return z; }(); std::cout 使用 auto 避免复制（ C++14 ） #include int main() { auto lam = [] (auto x) { return x + 1; }; std::cout #include #include int main() { std::map m{{4, 6}}; auto lam = [] (const std::pair& p) // 虽然使用了 const 但是还是会复制 { return p.first + p.second; }; std::cout Lifting （ C++14 ） #include #include auto fun(int val) { return val + 1; } auto fun(double val) { return val + 1; } int main() { // auto b = std::bind(fun, 3); // error: no matching function for call to // 'bind(, int)' // std::cout 递归调用（ C++14 ） #include int factorial(int n) { return n > 1 ? n * factorial(n - 1) : 1; } int main() { std::cout int { return n > 1 ? n * impl(n - 1, impl) : 1; }; return f_impl(n, f_impl); }; std::cout 在 C++ insights 中查看可以发现其中的原因（包括为什么加 -> int） Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-12 18:14:49 "},"chapterb/3.html":{"url":"chapterb/3.html","title":"泛型算法的改进——ranges","keywords":"","body":"泛型算法的改进——ranges #include #include #include int main() { std::vector x{1, 3, 5, 7}; auto it = std::find(x.begin(), x.end(), 3); std::cout 其中 std::ranges::find(x, 3) 可能会产生无效的迭代器，比如下面 #include #include #include auto fun() { return std::vector{1, 3, 5, 7}; } int main() { auto it = std::ranges::find(fun(), 3); std::cout 可以使用容器而非迭代器作为输入 通过 std::ranges::dangling 避免返回无效的迭代器 从类型上区分迭代器与哨兵 引入映射概念，简化代码编写 引入 view ，灵活组织程序逻辑 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-12 18:26:27 "},"chapterc/":{"url":"chapterc/","title":"类","keywords":"","body":"结构体与对象聚合 成员函数（方法） 访问限定符与友元 构造、析构与复制成员函数 字面值类，成员指针与 bind 交互 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-01 23:25:29 "},"chapterc/1.html":{"url":"chapterc/1.html","title":"结构体与对象聚合","keywords":"","body":"结构体与对象聚合 结构体：对基本数据结构进行扩展，将多个对象放置在一起视为一个整体 结构体的声明与定义（注意定义后面要跟分号来表示结束） 仅有声明的结构体是不完全类型（ incomplete type ） 结构体（以及类）的一处定义原则：翻译单元级别 数据成员（数据域）的声明与初始化 （ C++11 ）数据成员可以使用 decltype 来声明其类型，但不能使用 auto 数据成员声明时可以引入 const 、引用等限定 数据成员会在构造类对象时定义 （ C++11 ）类内成员初始化 聚合初始化：从初始化列表到指派初始化器 mutable 限定符 静态数据成员 —— 多个对象之间共享的数据成员 定义方式的衍化 C++98 ：类外定义， const 静态成员的类内初始化 C++17 ：内联静态成员的初始化 可以使用 auto 推导类型 静态数据成员的访问 “.” 与“ ->” 操作符 “::” 操作符 在类的内部声明相同类型的静态数据成员 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-12 20:48:29 "},"chapterc/2.html":{"url":"chapterc/2.html","title":"成员函数（方法）","keywords":"","body":"成员函数（方法） 可以在结构体中定义函数，作为其成员的一部分：对内操作数据成员，对外提供调用接口 在结构体中将数据与相关的成员函数组合在一起将形成类，是 C++ 在 C 基础上引入的概念 关键字 class 类可视为一种抽象数据类型，通过相应的接口（成员函数）进行交互 类本身形成域，称为类域 成员函数的声明与定义 类内定义（隐式内联） 类内声明 + 类外定义 类与编译期的两遍处理 成员函数与尾随返回类型（ trail returning type ） 成员函数与 this 指针 使用 this 指针引用当前对象 基于 const 的成员函数重载 成员函数的名称查找与隐藏关系 函数内部（包括形参名称）隐藏函数外部 类内部名称隐藏类外部 使用 this 或域操作符引入依赖型名称查找 静态成员函数 在静态成员函数中返回静态数据成员 成员函数基于引用限定符的重载（ C++11 ） Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-12 20:48:08 "},"chapterc/3.html":{"url":"chapterc/3.html","title":"访问限定符与友元","keywords":"","body":"访问限定符与友元 使用 public/private/protected 限定类成员的访问权限 访问权限的引入使得可以对抽象数据类型进行封装 类与结构体缺省访问权限的区别 使用友元打破访问权限限制 —— 关键字 friend 声明某个类或某个函数是当前类的友元 —— 慎用！ 在类内首次声明友元类或友元函数 注意使用限定名称引入友元并非友元类（友元函数）的声明 友元函数的类内外定义与类内定义 隐藏友元（ hidden friend ）：常规名称查找无法找到（参考文献） 好处：减轻编译器负担，防止误用 改变隐藏友元的缺省行为：在类外声明或定义函数 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-12 20:52:52 "},"chapterc/4.html":{"url":"chapterc/4.html","title":"构造、析构与复制成员函数","keywords":"","body":"构造、析构与复制成员函数 构造函数：构造对象时调用的函数 名称与类名相同，无返回值，可以包含多个版本（重载） （ C++11 ）代理构造函数 初始化列表：区分数据成员的初始化与赋值 通常情况下可以提升系统性能 一些情况下必须使用初始化列表（如类中包含引用成员） 注意元素的初始化顺序与其声明顺序相关，与初始化列表中的顺序无关 使用初始化列表覆盖类内成员初始化的行为 缺省构造函数：不需要提供实际参数就可以调用的构造函数 如果类中没有提供任何构造函数，那么在条件允许的情况下，编译器会合成一个缺省构造函数 合成的缺省构造函数会使用缺省初始化来初始化其数据成员 调用缺省构造函数时避免 most vexing parse 使用 default 关键字定义缺省构造函数 单一参数构造函数 可以视为一种类型转换函数 可以使用 explicit 关键字避免求值过程中的隐式转换 拷贝构造函数：接收一个当前类对象的构造函数 会在涉及到拷贝初始化的场景被调用，比如：参数传递。因此要注意拷贝构造函数的形参类型 如果未显式提供，那么编译器会自动合成一个，合成的版本会依次对每个数据成员调用拷贝构造 移动构造函数 (C++11) ：接收一个当前类右值引用对象的构造函数 可以从输入对象中 “偷窃” 资源，只要确保传入对象处于合法状态即可 当某些特殊成员函数（如拷贝构造）未定义时，编译器可以合成一个 通常声明为不可抛出异常的函数 注意右值引用对象用做表达式时是左值！ 拷贝赋值与移动赋值函数（ operator = ） 注意赋值函数不能使用初始化列表 通常来说返回当前类型的引用 注意处理给自身赋值的情况 在一些情况下编译器会自动合成 析构函数 函数名：～ 加当前类型，无参数，无返回值 用于释放资源 注意内存回收是在调用完析构函数时才进行 除非显式声明，否则编译器会自动合成一个，其内部逻辑为平凡的 析构函数通常不能抛出异常 [!TIP] 通常来说，一个类： 如果需要定义析构函数，那么也需要定义拷贝构造与拷贝赋值函数 如果需要定义拷贝构造函数，那么也需要定义拷贝赋值函数 如果需要定义拷贝构造（赋值）函数，那么也要考虑定义移动构造（赋值）函数 示例：包含指针的类 default 关键字 只对特殊成员函数有效 delete 关键字 对所有函数都有效 注意其与未声明的区别 注意不要为移动构造（移动赋值）函数引入 delete 限定符 如果只需要拷贝行为，那么引入拷贝构造即可 如果不需要拷贝行为，那么将拷贝构造声明为 delete 函数即可 注意 delete 移动构造（移动赋值）对 C++17 的新影响 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-12 21:01:03 "},"chapterc/5.html":{"url":"chapterc/5.html","title":"字面值类，成员指针与 bind 交互","keywords":"","body":"字面值类，成员指针与 bind 交互 字面值类：可以构造编译期常量的类型 其数据成员需要是字面值类型 提供 constexpr / consteval 构造函数 （小心使用 consteval ） 平凡的析构函数 提供 constexpr / consteval 成员函数 （小心使用 consteval ） 注意：从 C++14 起 constexpr / consteval 成员函数非 const 成员函数 成员指针 数据成员指针类型示例： int A::*; 成员函数指针类型示例： int (A::*)(double); 成员指针对象赋值： auto ptr = &A::x; 注意域操作符子表达式不能加小括号（否则 A::x 一定要有意义） 成员指针的使用： 对象 .* 成员指针 对象指针 ->* 成员指针 bind 交互 使用 bind + 成员指针构造可调用对象 注意这种方法也可以基于数据成员指针构造可调用对象 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-12 21:03:12 "},"chapterd/":{"url":"chapterd/","title":"类进阶","keywords":"","body":"运算符重载 类的继承 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-01 23:28:19 "},"chapterd/1.html":{"url":"chapterd/1.html","title":"运算符重载","keywords":"","body":"运算符重载 使用 operator 关键字引入重载函数 重载不能发明新的运算，不能改变运算的优先级与结合性，通常不改变运算含义 函数参数个数与运算操作数个数相同，至少一个为类类型 除 operator() 外其它运算符不能有缺省参数 可以选择实现为成员函数与非成员函数 通常来说，实现为成员函数会以 *this 作为第一个操作数（注意 == 与 的重载） 根据重载特性，可以将运算符进一步划分（参考资料） 可重载且必须实现为成员函数的运算符（ =,[],(),-> 与转型运算符） 可重载且可以实现为非成员函数的运算符 可重载但不建议重载的运算符（ &&, ||, 逗号运算符） C++17 中规定了相应的求值顺序但没有方式实现短路逻辑 不可重载的运算符（如 ? ： 运算符） 重载详述 对称运算符通常定义为非成员函数以支持首个操作数的类型转换 移位运算符一定要定义为非成员函数，因为其首个操作数类型为流类型 赋值运算符也可以接收一般参数 operator [] 通常返回引用 自增、自减运算符的前缀、后缀重载方法 使用解引用运算符（ * ）与成员访问运算符（ -> ）模拟指针行为 注意“ .” 运算符不能重载 “→” 会递归调用 操作 “→” 使用函数调用运算符构造可调用对象 类型转换运算符 函数声明为 operator type() const 与单参数构造函数一样，都引入了一种类型转换方式 注意避免引入歧义性与意料之外的行为 通过 explicit 引入显式类型转换 explicit bool 的特殊性：用于条件表达式时会进行隐式类型转换 C++ 20 中对 == 与 的重载 通过 == 定义 != 通过 定义多种比较逻辑 隐式交换操作数 注意 可返回的类型： strong_ordering, week_ordering, partial_ordering Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-12 21:09:55 "},"chapterd/2.html":{"url":"chapterd/2.html","title":"类的继承","keywords":"","body":"类的继承 通过类的继承（派生）来引入 \"是一个\" 的关系 通常采用 public 继承（ struct V.S. class ） 注意：继承部分不是类的声明 使用基类的指针或引用可以指向派生类对象 静态类型 V.S. 动态类型 protected 限定符：派生类可访问 类的派生会形成嵌套域 派生类所在域位于基类内部 派生类中的名称定义会覆盖基类 使用域操作符显式访问基类成员 在派生类中调用基类的构造函数 虚函数 通过虚函数与引用（指针）实现动态绑定 使用关键字 virtual 引入 非静态、非构造函数可声明为虚函数 虚函数会引入 vtable 结构 dynamic_cast 虚函数在基类中的定义 引入缺省逻辑 可以通过 = 0 声明纯虚函数，相应地构造抽象基类 虚函数在派生类中的重写（ override ） 函数签名保持不变（返回类型可以是原始返回指针 / 引用类型的派生指针 / 引用类型） 虚函数特性保持不变 override 关键字 由虚函数所引入的动态绑定属于运行期行为，与编译期行为有所区别 虚函数的缺省实参只会考虑静态类型 虚函数的调用成本高于非虚函数 final 关键字 为什么要使用指针（或引用）引入动态绑定 在构造函数中调用虚函数要小心 派生类的析构函数会隐式调用基类的析构函数 通常来说要将基类的析构函数声明为 virtual 的 在派生类中修改虚函数的访问权限 继承与特殊成员函数 派生类合成的…… 缺省构造函数会隐式调用基类的缺省构造函数 拷贝构造函数将隐式调用基类的拷贝构造函数 赋值函数将隐式调用基类的赋值函数 派生类的析构函数会调用基类的析构函数 派生类的其它构造函数将隐式调用基类的缺省构造函数 所有的特殊成员函数在显式定义时都可能需要显式调用基类相关成员 构造与销毁顺序 基类的构造函数会先调用，之后才涉及到派生类中数据成员的构造 派生类中的数据成员会被先销毁，之后才涉及到基类的析构函数调用 补充知识 public 与 private 继承（参考资料） public 继承：描述 “是一个”的关系 private 继承：描述“根据基类实现出” 的关系 protected 继承：几乎不会使用 using 与继承 使用 using 改变基类成员的访问权限 派生类可以访问该成员 无法改变构造函数的访问权限 使用 using 继承基类的构造函数逻辑 using 与部分重写 其他 继承与友元：友元关系无法继承，但基类的友元可以访问派生类中基类的相关成员- 的继承——补充知识续 通过基类指针实现在容器中保存不同类型对象 多重继承与虚继承 空基类优化与 [[no_unique_address]] 属性 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-12 21:20:44 "},"chaptere/":{"url":"chaptere/","title":"模板","keywords":"","body":"函数模板 类模板与成员函数模板 Concepts 模板相关内容 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-01 23:30:17 "},"chaptere/1.html":{"url":"chaptere/1.html","title":"函数模板","keywords":"","body":"函数模板 使用 template 关键字引入模板： template void fun(T) {...} 函数模板的声明与定义 typename 关键字可以替换为 class ，含义相同 函数模板中包含了两对参数：函数形参 / 实参；模板形参 / 实参 函数模板的显式实例化： fun(3) 实例化会使得编译器产生相应的函数（函数模板并非函数，不能调用） 编译期的两阶段处理 模板语法检查 模板实例化 模板必须在实例化时可见 —— 翻译单元的一处定义原则 注意与内联函数的异同 函数模板的重载 模板实参的类型推导 如果函数模板在实例化时没有显式指定模板实参，那么系统会尝试进行推导 推导是基于函数实参（表达式）确定模板实参的过程，其基本原则与 auto 类型推导相似 函数形参是左值引用 / 指针： 忽略表达式类型中的引用 将表达式类型与函数形参模式匹配以确定模板实参 函数形参是万能引用 如果实参表达式是右值，那么模板形参被推导为去掉引用的基本类型 如果实参表达式是左值，那么模板形参被推导为左值引用，触发引用折叠 函数形参不包含引用 忽略表达式类型中的引用 忽略顶层 const 数组、函数转换成相应的指针类型 模板实参并非总是能够推导得到 如果模板形参与函数形参无关，则无法推导 即使相关，也不一定能进行推导，推导成功也可能存在因歧义而无法使用 在无法推导时，编译器会选择使用缺省模板实参 可以为任意位置的模板形参指定缺省模板实参 —— 注意与函数缺省实参的区别 显式指定部分模板实参 显式指定的模板实参必须从最左边开始，依次指定 模板形参的声明顺序会影响调用的灵活性 函数模板制动推导时会遇到的几种情况 函数形参无法匹配—— SFINAE （替换失败并非错误） 模板与非模板同时匹配，匹配等级相同，此时选择非模板的版本 多个模板同时匹配，此时采用偏序关系确定选择 最特殊 的版本 函数模板的实例化控制 显式实例化定义： template void fun(int) / template void fun(int) 显式实例化声明： extern template void fun(int) / extern template void fun(int) 注意一处定义原则 注意实例化过程中的模板形参推导 函数模板的 ( 完全 ) 特化： template<> void f(int) / template<> void f(int) 并不引入新的（同名）名称，只是为某个模板针对特定模板实参提供优化算法 注意与重载的区别 注意特化过程中的模板形参推导 避免使用函数模板的特化 不参与重载解析，会产生反直觉的效果 通常可以用重载代替 一些不便于重载的情况：无法建立模板形参与函数形参的关联 使用 if constexpr 解决 引入 假 函数形参 通过类模板特化解决 (C++20) 函数模板的简化形式：使用 auto 定义模板参数类型 优势：书写简捷 劣势：在函数内部需要间接获取参数类型信息 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-12 21:46:29 "},"chaptere/2.html":{"url":"chaptere/2.html","title":"类模板与成员函数模板","keywords":"","body":"类模板与成员函数模板 使用 template 关键字引入模板： template class B {…}; 类模板的声明与定义 翻译单元的一处定义原则 —— 成员函数只有在调用时才会被实例化 类内类模板名称的简写 类模板成员函数的定义（类内、类外） 成员函数模板 类的成员函数模板 类模板的成员函数模板 友元函数（模板） 可以声明一个函数模板为某个类（模板）的友元 C++11 支持声明模板参数为友元 类模板的实例化 (https://en.cppreference.com/w/cpp/language/class_template) 与函数实例化很像 可以实例化整个类，或者类中的某个成员函数 类模板的（完全）特化 / 部分特化（偏特化） 特化版本与基础版本可以拥有完全不同的实现 类模板的实参推导（从 C++17 开始） 基于构造函数的实参推导 用户自定义的推导指引 注意：引入实参推导并不意味着降低了类型限制！ C++ 17 之前的解决方案：引入辅助模板函数 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-12 21:48:40 "},"chaptere/3.html":{"url":"chaptere/3.html","title":"Concepts","keywords":"","body":"Concepts 模板的问题：没有对模板参数引入相应的限制 参数是否可以正常工作，通常需要阅读代码进行理解 编译报错友好性较差 (vector) （ C++20 ） Concepts ：编译期谓词，基于给定的输入，返回 true 或 false 与 constraints （ require 从句）一起使用限制模板参数 通常置于表示模板形参的尖括号后面进行限制 Concept 的定义与使用 包含一个模板参数的 Concept 使用 requires 从句 直接替换 typename 包含多个模板参数的 Concept 用做类型 constraint 时，少传递一个参数，推导出的类型将作为首个参数 requires 表达式 简单表达式：表明可以接收的操作 类型表达式：表明是一个有效的类型 复合表达式：表明操作的有效性，以及操作返回类型的特性 嵌套表达式：包含其它的限定表达式 注意区分 requires 从句与 requires 表达式 requires 从句会影响重载解析与特化版本的选取 只有 requires 从句有效而且返回为 true 时相应的模板才会被考虑 requires 从句所引入的限定具有偏序特性，系统会选择限制最严格的版本 特化小技巧：在声明中引入“ A||B” 进行限制，之后分别针对 A 与 B 引入特化 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-12 21:51:54 "},"chaptere/4.html":{"url":"chaptere/4.html","title":"模板相关内容","keywords":"","body":"模板相关内容 数值模板参数与模板模板参数 模板可以接收（编译期常量）数值作为模板参数 template class Str; template class Str; (C++ 17) template class Str; (C++ 20) 接收字面值类对象与浮点数作为模板参数 目前 clang 12 不支持接收浮点数作为模板参数 接收模板作为模板参数 template class C> class Str; (C++17) template typename C> class Str; C++17 开始，模板的模板实参考虑缺省模板实参（ clang 12 支持程度有限） Str 是否支持？ 别名模板与变长模板 可以使用 using 引入别名模板 为模板本身引入别名 为类模板的成员引入别名 别名模板不支持特化，但可以基于类模板的特化引入别名，以实现类似特化的功能 注意与实参推导的关系 变长模板（ Variadic Template ） 变长模板参数与参数包 变长模板参数可以是数值、类型或模板 sizeof... 操作 注意变长模板参数的位置 包展开与折叠表达式 (C++11) 通过包展开技术操作变长模板参数 包展开语句可以很复杂，需要明确是哪一部分展开，在哪里展开 (C++17) 折叠表达式 (cpp reference) 基于逗号的折叠表达式应用 折叠表达式用于表达式求值，无法处理输入（输出）是类型与模板的情形 完美转发与 lambda 表达式模板 (C++11) 完美转发： std::forward 函数 通常与万能引用结合使用 同时处理传入参数是左值或右值的情形 (C++20) lambda 表达式模板 消除歧义与变量模板 使用 typename 与 template 消除歧义 使用 typename 表示一个依赖名称是类型而非静态数据成员 使用 template 表示一个依赖名称是模板 template 与成员函数模板调用 (C++14) 变量模板 template T pi = (T)3.1415926; 其它形式的变量模板 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-12 21:57:26 "},"chapterf/":{"url":"chapterf/","title":"元编程","keywords":"","body":"元编程的引入 顺序、分支、循环代码的编写方式 减少实例化的技巧 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-01 23:33:43 "},"chapterf/1.html":{"url":"chapterf/1.html","title":"元编程的引入","keywords":"","body":"元编程的引入 从泛型编程到元编程 泛型编程 ——使用一套代码处理不同类型 对于一些特殊的类型需要引入额外的处理逻辑 —— 引入操纵程序的程序 元编程与编译期计算 第一个元程序示例（ Erwin Unruh） 在编译错误中产生质数 使用编译期运算辅助运行期计算 不是简单地将整个运算一分为二 详细分析哪些内容可以放到编译期，哪些需要放到运行期 如果某种信息需要在运行期确定，那么通常无法利用编译期计算 元程序的形式 模板， constexpr 函数，其它编译期可使用的函数（如 sizeof ） 通常以函数为单位，也被称为函数式编程 元数据 基本元数据：数值、类型、模板 数组 元程序的性质 输入输出均为 “常亮” 函数无副作用 type_traits元编程库 C++11 引入到标准中，用于元编程的基本组件 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-12 21:26:36 "},"chapterf/2.html":{"url":"chapterf/2.html","title":"顺序、分支、循环代码的编写方式","keywords":"","body":"顺序、分支、循环代码的编写方式 顺序代码的编写方式 类型转换示例：为输入类型去掉引用并添加 const 代码无需至于函数中 通常置于模板中，以头文件的形式提供 更复杂的示例： 以数值、类型、模板作为输入 以数值、类型、模板作为输出 引入限定符防止误用 通过别名模板简化调用方式 分支代码的编写方式 基于 if constexpr 的分支：便于理解只能处理数值，同时要小心引入运行期计算 基于（偏）特化引入分支：常见分支引入方式但书写麻烦 基于 std::conditional 引入分支：语法简单但应用场景受限 基于 SFINAE 引入分支 基于 std::enable_if 引入分支：语法不易懂但功能强大 注意用做缺省模板实参不能引入分支！ 基于 std::void_t 引入分支： C++17 中的新方法，通过 “无效语句” 触发分支 基于 concept 引入分支： C++20 中的方法 可用于替换 enable_if 基于三元运算符引入分支： std::conditional 的数值版本 循环代码的编写方式 简单示例：计算二进制中包含 1 的个数 使用递归实现循环 任何一种分支代码的编写方式都对应相应的循环代码编写方式 使用循环处理数组：获取数组中 id=0,2,4,6... 的元素 相对复杂的示例：获取数组中最后三个元素 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-12 21:29:01 "},"chapterf/3.html":{"url":"chapterf/3.html","title":"减少实例化的技巧","keywords":"","body":"减少实例化的技巧 为什么要减少实例化 - 提升编译速度，减少编译所需内存 相关技巧 提取重复逻辑以减少实例个数 conditional 使用时避免实例化 使用 std::conjunction / std::disjunction 引入短路逻辑 其它技巧介绍 减少分摊复杂度的数组元素访问操作 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-12 21:30:03 "},"chapterg/":{"url":"chapterg/","title":"其他的工具与技术","keywords":"","body":"异常处理 枚举与联合 嵌套类与局部类 嵌套名字空间与匿名名字空间 位域与 volatile 关键字 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-01 23:37:19 "},"chapterg/1.html":{"url":"chapterg/1.html","title":"异常处理","keywords":"","body":"异常处理 用于处理程序在调用过程中的非正常行为 传统的处理方法：传返回值表示函数调用是否正常结束 C++ 中的处理方法：通过关键字 try/catch/throw 引入异常处理机制 异常触发时的系统行为 —— 栈展开 抛出异常后续的代码不会被执行 局部对象会按照构造相反的顺序自动销毁 系统尝试匹配相应的 catch 代码段 如果匹配则执行其中的逻辑，之后执行 catch 后续的代码 如果不匹配则继续进行栈展开，直到 跳出 “ main” 函数，触发 terminate 结束运行 异常对象 系统会使用抛出的异常拷贝初始化一个临时对象，称为异常对象 异常对象会在栈展开过程中被保留，并最终传递给匹配的 catch 语句 try / catch 语句块 一个 try 语句块后面可以跟一到多个 catch 语句块 每个 catch 语句块用于匹配一种类型的异常对象 catch 语句块的匹配按照从上到下进行 使用 catch(...) 匹配任意异常 在 catch 中调用 throw 继续抛出相同的异常 在一个异常未处理完成时抛出新的异常会导致程序崩溃 不要在析构函数或 operator delete 函数重载版本中抛出异常 通常来说， catch 所接收的异常类型为引用类型 异常与构造、析构函数 使用 function-try-block 保护初始化逻辑 在构造函数中抛出异常： 已经构造的成员会被销毁，但类本身的析构函数不会被调用 描述函数是否会抛出异常 如果函数不会抛出异常，则应表明以为系统提供更多的优化空间 C++ 98 的方式： throw() / throw(int, char) C++11 后的改进： noexcept / noexcept(false) noexcept 限定符：接收 false / true 表示是否会抛出异常 操作符：接收一个表达式，根据表达式是否可能抛出异常返回 false/true 在声明了 noexcept 的函数中抛出异常会导致 terminate 被调用，程序终止 不作为函数重载依据，但函数指针、虚拟函数重写时要保持形式兼容 正确对待异常处理 不要滥用：异常的执行成本非常高 不要不用：对于真正的异常场景，异常处理是相对高效、简洁的处理方式 编写异常安全的代码 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-12 21:35:07 "},"chapterg/2.html":{"url":"chapterg/2.html","title":"枚举与联合","keywords":"","body":"枚举与联合 枚举(enum) ：一种取值受限的特殊类型 分为无作用域枚举与有作用域枚举（ C++11 起）两种 枚举项缺省使用 0 初始化，依次递增，可以使用常量表达式来修改缺省值 可以为枚举指定底层类型，表明了枚举项的尺寸 无作用域枚举项可隐式转换为整数值；也可用 static_cast 在枚举项与整数值间转换 注意区分枚举的定义与声明 联合（ union ）：将多个类型合并到一起以节省空间 通常与枚举一起使用 匿名联合 在联合中包含非内建类型（ C++11 起） Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-12 21:36:00 "},"chapterg/3.html":{"url":"chapterg/3.html","title":"嵌套类与局部类","keywords":"","body":"嵌套类与局部类 嵌套类：在类中定义的类 嵌套类具有自己的域，与外围类的域形成嵌套关系 嵌套类中的名称查找失败时会在其外围类中继续查找 嵌套类与外围类单独拥有各自的成员 局部类：可以在函数内部定义的类 可以访问外围函数中定义的类型声明、静态对象与枚举 局部类可以定义成员函数，但成员函数的定义必须位于类内部 局部类不能定义静态数据成员 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-12 21:36:33 "},"chapterg/4.html":{"url":"chapterg/4.html","title":"嵌套名字空间与匿名名字空间","keywords":"","body":"嵌套名字空间与匿名名字空间 嵌套名字空间 名字空间可以嵌套，嵌套名字空间形成嵌套域 注意同样的名字空间定义可以出现在程序多处，以向同一个名字空间中增加声明或定义 C++17 开始可以简化嵌套名字空间的定义 匿名名字空间 用于构造仅翻译单元可见的对象 可用 static 代替 可作为嵌套名字空间 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-12 21:37:03 "},"chapterg/5.html":{"url":"chapterg/5.html","title":"位域与 volatile 关键字","keywords":"","body":"位域与 volatile 关键字 位域：显示表明对象尺寸（所占位数） 在结构体 / 类中使用 多个位域对象可能会被打包存取 声明了位域的对象无法取地址，因此不能使用指针或非常量引用进行绑定 尺寸通常会小于对象类型所对应的尺寸，否则取值受类型限制 volatile关键字 表明一个对象的可能会被当前程序以外的逻辑修改 相应对象的读写可能会加重程序负担 注意慎重使用 一 —— 些情况下可以用 atomic 代替 Copyright © https://yian-code.github.io/yian/ all right reserved，powered by Gitbook该文件修订时间： 2023-01-12 21:37:47 "}}